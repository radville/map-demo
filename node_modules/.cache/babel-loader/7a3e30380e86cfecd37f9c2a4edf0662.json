{"ast":null,"code":"define([\"./has\"], function (has) {\n  \"use strict\";\n\n  var hasJSON = typeof JSON != \"undefined\";\n  has.add(\"json-parse\", hasJSON); // all the parsers work fine\n  // Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184\n\n  has.add(\"json-stringify\", hasJSON && JSON.stringify({\n    a: 0\n  }, function (k, v) {\n    return v || 1;\n  }) == '{\"a\":1}');\n  /*=====\n  return {\n  \t// summary:\n  \t//\t\tFunctions to parse and serialize JSON\n  \t\tparse: function(str, strict){\n  \t\t// summary:\n  \t\t//\t\tParses a [JSON](http://json.org) string to return a JavaScript object.\n  \t\t// description:\n  \t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n  \t\t//\t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\n  \t\t//\t\tsupport is not available. By default this will evaluate any valid JS expression.\n  \t\t//\t\tWith the strict parameter set to true, the parser will ensure that only\n  \t\t//\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\n  \t\t//\t\tparameter, the content passed to this method must come\n  \t\t//\t\tfrom a trusted source.\n  \t\t// str:\n  \t\t//\t\ta string literal of a JSON item, for instance:\n  \t\t//\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n  \t\t// strict:\n  \t\t//\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\n  \t\t//\t\tMake sure this is set to true for untrusted content. Note that on browsers/engines\n  \t\t//\t\twithout native JSON support, setting this to true will run slower.\n  \t},\n  \tstringify: function(value, replacer, spacer){\n  \t\t// summary:\n  \t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n  \t\t// description:\n  \t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n  \t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n  \t\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\n  \t\t// value:\n  \t\t//\t\tA value to be serialized.\n  \t\t// replacer:\n  \t\t//\t\tA replacer function that is called for each value and can return a replacement\n  \t\t// spacer:\n  \t\t//\t\tA spacer string to be used for pretty printing of JSON\n  \t\t// example:\n  \t\t//\t\tsimple serialization of a trivial object\n  \t\t//\t|\tdefine([\"dojo/json\"], function(JSON){\n  \t\t// \t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\n  \t\t//\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n  \t}\n  };\n  =====*/\n\n  if (has(\"json-stringify\")) {\n    return JSON;\n  } else {\n    var escapeString = function (\n    /*String*/\n    str) {\n      // summary:\n      //\t\tAdds escape sequences for non-visual characters, double quote and\n      //\t\tbackslash and surrounds with double quotes to form a valid string\n      //\t\tliteral.\n      return ('\"' + str.replace(/([\"\\\\])/g, '\\\\$1') + '\"').replace(/[\\f]/g, \"\\\\f\").replace(/[\\b]/g, \"\\\\b\").replace(/[\\n]/g, \"\\\\n\").replace(/[\\t]/g, \"\\\\t\").replace(/[\\r]/g, \"\\\\r\"); // string\n    };\n\n    return {\n      parse: has(\"json-parse\") ? JSON.parse : function (str, strict) {\n        if (strict && !/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])*\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$/.test(str)) {\n          throw new SyntaxError(\"Invalid characters in JSON\");\n        }\n\n        return eval('(' + str + ')');\n      },\n      stringify: function (value, replacer, spacer) {\n        var undef;\n\n        if (typeof replacer == \"string\") {\n          spacer = replacer;\n          replacer = null;\n        }\n\n        function stringify(it, indent, key) {\n          if (replacer) {\n            it = replacer(key, it);\n          }\n\n          var val,\n              objtype = typeof it;\n\n          if (objtype == \"number\") {\n            return isFinite(it) ? it + \"\" : \"null\";\n          }\n\n          if (objtype == \"boolean\") {\n            return it + \"\";\n          }\n\n          if (it === null) {\n            return \"null\";\n          }\n\n          if (typeof it == \"string\") {\n            return escapeString(it);\n          }\n\n          if (objtype == \"function\" || objtype == \"undefined\") {\n            return undef; // undefined\n          } // short-circuit for objects that support \"json\" serialization\n          // if they return \"self\" then just pass-through...\n\n\n          if (typeof it.toJSON == \"function\") {\n            return stringify(it.toJSON(key), indent, key);\n          }\n\n          if (it instanceof Date) {\n            return '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(/\\{(\\w+)(\\+)?\\}/g, function (t, prop, plus) {\n              var num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\n              return num < 10 ? \"0\" + num : num;\n            });\n          }\n\n          if (it.valueOf() !== it) {\n            // primitive wrapper, try again unwrapped:\n            return stringify(it.valueOf(), indent, key);\n          }\n\n          var nextIndent = spacer ? indent + spacer : \"\";\n          /* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */\n\n          var sep = spacer ? \" \" : \"\";\n          var newLine = spacer ? \"\\n\" : \"\"; // array\n\n          if (it instanceof Array) {\n            var itl = it.length,\n                res = [];\n\n            for (key = 0; key < itl; key++) {\n              var obj = it[key];\n              val = stringify(obj, nextIndent, key);\n\n              if (typeof val != \"string\") {\n                val = \"null\";\n              }\n\n              res.push(newLine + nextIndent + val);\n            }\n\n            return \"[\" + res.join(\",\") + newLine + indent + \"]\";\n          } // generic object code path\n\n\n          var output = [];\n\n          for (key in it) {\n            var keyStr;\n\n            if (it.hasOwnProperty(key)) {\n              if (typeof key == \"number\") {\n                keyStr = '\"' + key + '\"';\n              } else if (typeof key == \"string\") {\n                keyStr = escapeString(key);\n              } else {\n                // skip non-string or number keys\n                continue;\n              }\n\n              val = stringify(it[key], nextIndent, key);\n\n              if (typeof val != \"string\") {\n                // skip non-serializable values\n                continue;\n              } // At this point, the most non-IE browsers don't get in this branch \n              // (they have native JSON), so push is definitely the way to\n\n\n              output.push(newLine + nextIndent + keyStr + \":\" + sep + val);\n            }\n          }\n\n          return \"{\" + output.join(\",\") + newLine + indent + \"}\"; // String\n        }\n\n        return stringify(value, \"\", \"\");\n      }\n    };\n  }\n});","map":{"version":3,"sources":["/Users/Laura/Development/solar-calculator/node_modules/dojo/json.js"],"names":["define","has","hasJSON","JSON","add","stringify","a","k","v","escapeString","str","replace","parse","strict","test","SyntaxError","eval","value","replacer","spacer","undef","it","indent","key","val","objtype","isFinite","toJSON","Date","t","prop","plus","num","valueOf","nextIndent","sep","newLine","Array","itl","length","res","obj","push","join","output","keyStr","hasOwnProperty"],"mappings":"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","sourcesContent":["define([\"./has\"], function(has){\n\t\"use strict\";\n\tvar hasJSON = typeof JSON != \"undefined\";\n\thas.add(\"json-parse\", hasJSON); // all the parsers work fine\n\t\t// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184\n\thas.add(\"json-stringify\", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{\"a\":1}');\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tFunctions to parse and serialize JSON\n\n\t\tparse: function(str, strict){\n\t\t\t// summary:\n\t\t\t//\t\tParses a [JSON](http://json.org) string to return a JavaScript object.\n\t\t\t// description:\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t//\t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\n\t\t\t//\t\tsupport is not available. By default this will evaluate any valid JS expression.\n\t\t\t//\t\tWith the strict parameter set to true, the parser will ensure that only\n\t\t\t//\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\n\t\t\t//\t\tparameter, the content passed to this method must come\n\t\t\t//\t\tfrom a trusted source.\n\t\t\t// str:\n\t\t\t//\t\ta string literal of a JSON item, for instance:\n\t\t\t//\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n\t\t\t// strict:\n\t\t\t//\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\n\t\t\t//\t\tMake sure this is set to true for untrusted content. Note that on browsers/engines\n\t\t\t//\t\twithout native JSON support, setting this to true will run slower.\n\t\t},\n\t\tstringify: function(value, replacer, spacer){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t// description:\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\n\t\t\t// value:\n\t\t\t//\t\tA value to be serialized.\n\t\t\t// replacer:\n\t\t\t//\t\tA replacer function that is called for each value and can return a replacement\n\t\t\t// spacer:\n\t\t\t//\t\tA spacer string to be used for pretty printing of JSON\n\t\t\t// example:\n\t\t\t//\t\tsimple serialization of a trivial object\n\t\t\t//\t|\tdefine([\"dojo/json\"], function(JSON){\n\t\t\t// \t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\n\t\t\t//\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n\t\t}\n\t};\n\t=====*/\n\n\tif(has(\"json-stringify\")){\n\t\treturn JSON;\n\t}else{\n\t\tvar escapeString = function(/*String*/str){\n\t\t\t// summary:\n\t\t\t//\t\tAdds escape sequences for non-visual characters, double quote and\n\t\t\t//\t\tbackslash and surrounds with double quotes to form a valid string\n\t\t\t//\t\tliteral.\n\t\t\treturn ('\"' + str.replace(/([\"\\\\])/g, '\\\\$1') + '\"').\n\t\t\t\treplace(/[\\f]/g, \"\\\\f\").replace(/[\\b]/g, \"\\\\b\").replace(/[\\n]/g, \"\\\\n\").\n\t\t\t\treplace(/[\\t]/g, \"\\\\t\").replace(/[\\r]/g, \"\\\\r\"); // string\n\t\t};\n\t\treturn {\n\t\t\tparse: has(\"json-parse\") ? JSON.parse : function(str, strict){\n\t\t\t\tif(strict && !/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])*\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$/.test(str)){\n\t\t\t\t\tthrow new SyntaxError(\"Invalid characters in JSON\");\n\t\t\t\t}\n\t\t\t\treturn eval('(' + str + ')');\n\t\t\t},\n\t\t\tstringify: function(value, replacer, spacer){\n\t\t\t\tvar undef;\n\t\t\t\tif(typeof replacer == \"string\"){\n\t\t\t\t\tspacer = replacer;\n\t\t\t\t\treplacer = null;\n\t\t\t\t}\n\t\t\t\tfunction stringify(it, indent, key){\n\t\t\t\t\tif(replacer){\n\t\t\t\t\t\tit = replacer(key, it);\n\t\t\t\t\t}\n\t\t\t\t\tvar val, objtype = typeof it;\n\t\t\t\t\tif(objtype == \"number\"){\n\t\t\t\t\t\treturn isFinite(it) ? it + \"\" : \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"boolean\"){\n\t\t\t\t\t\treturn it + \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(it === null){\n\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(typeof it == \"string\"){\n\t\t\t\t\t\treturn escapeString(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"function\" || objtype == \"undefined\"){\n\t\t\t\t\t\treturn undef; // undefined\n\t\t\t\t\t}\n\t\t\t\t\t// short-circuit for objects that support \"json\" serialization\n\t\t\t\t\t// if they return \"self\" then just pass-through...\n\t\t\t\t\tif(typeof it.toJSON == \"function\"){\n\t\t\t\t\t\treturn stringify(it.toJSON(key), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tif(it instanceof Date){\n\t\t\t\t\t\treturn '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(/\\{(\\w+)(\\+)?\\}/g, function(t, prop, plus){\n\t\t\t\t\t\t\tvar num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\n\t\t\t\t\t\t\treturn num < 10 ? \"0\" + num : num;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(it.valueOf() !== it){\n\t\t\t\t\t\t// primitive wrapper, try again unwrapped:\n\t\t\t\t\t\treturn stringify(it.valueOf(), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tvar nextIndent= spacer ? (indent + spacer) : \"\";\n\t\t\t\t\t/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ \n\t\t\t\t\n\t\t\t\t\tvar sep = spacer ? \" \" : \"\";\n\t\t\t\t\tvar newLine = spacer ? \"\\n\" : \"\";\n\t\t\t\t\n\t\t\t\t\t// array\n\t\t\t\t\tif(it instanceof Array){\n\t\t\t\t\t\tvar itl = it.length, res = [];\n\t\t\t\t\t\tfor(key = 0; key < itl; key++){\n\t\t\t\t\t\t\tvar obj = it[key];\n\t\t\t\t\t\t\tval = stringify(obj, nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\tval = \"null\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tres.push(newLine + nextIndent + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"[\" + res.join(\",\") + newLine + indent + \"]\";\n\t\t\t\t\t}\n\t\t\t\t\t// generic object code path\n\t\t\t\t\tvar output = [];\n\t\t\t\t\tfor(key in it){\n\t\t\t\t\t\tvar keyStr;\n\t\t\t\t\t\tif(it.hasOwnProperty(key)){\n\t\t\t\t\t\t\tif(typeof key == \"number\"){\n\t\t\t\t\t\t\t\tkeyStr = '\"' + key + '\"';\n\t\t\t\t\t\t\t}else if(typeof key == \"string\"){\n\t\t\t\t\t\t\t\tkeyStr = escapeString(key);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// skip non-string or number keys\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval = stringify(it[key], nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\t// skip non-serializable values\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// At this point, the most non-IE browsers don't get in this branch \n\t\t\t\t\t\t\t// (they have native JSON), so push is definitely the way to\n\t\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn \"{\" + output.join(\",\") + newLine + indent + \"}\"; // String\n\t\t\t\t}\n\t\t\t\treturn stringify(value, \"\", \"\");\n\t\t\t}\n\t\t};\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}