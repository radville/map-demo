(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./support/selector", "../widget-core/d"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var selector_1 = require("./support/selector");
    var d_1 = require("../widget-core/d");
    var findOne = function (nodes, selector) {
        var finalSelector = selector;
        if (selector.indexOf('~') === 0) {
            finalSelector = "[\\~key='" + selector.substr(1) + "']";
        }
        var _a = tslib_1.__read(selector_1.default(finalSelector, nodes), 1), node = _a[0];
        if (!node) {
            finalSelector = "[assertion-key='" + selector.substr(1) + "']";
            _b = tslib_1.__read(selector_1.default(finalSelector, nodes), 1), node = _b[0];
        }
        return node;
        var _b;
    };
    var guard = function (node) {
        if (!node) {
            throw Error('Node not found');
        }
        if (!d_1.isWNode(node) && !d_1.isVNode(node)) {
            throw Error('Cannot set or get on unknown node');
        }
        return node;
    };
    function assertionTemplate(renderFunc) {
        var assertionTemplateResult = function () {
            var render = renderFunc();
            d_1.decorate(render, function (node) {
                if (d_1.isWNode(node) || d_1.isVNode(node)) {
                    delete node.properties['~key'];
                    delete node.properties['assertion-key'];
                }
            });
            return render;
        };
        assertionTemplateResult.setProperty = function (selector, property, value) {
            return assertionTemplate(function () {
                var render = renderFunc();
                var node = guard(findOne(render, selector));
                node.properties[property] = value;
                return render;
            });
        };
        assertionTemplateResult.append = function (selector, children) {
            return assertionTemplateResult.setChildren(selector, children, 'append');
        };
        assertionTemplateResult.prepend = function (selector, children) {
            return assertionTemplateResult.setChildren(selector, children, 'prepend');
        };
        assertionTemplateResult.replace = function (selector, children) {
            return assertionTemplateResult.setChildren(selector, children, 'replace');
        };
        assertionTemplateResult.setChildren = function (selector, children, type) {
            if (type === void 0) { type = 'replace'; }
            return assertionTemplate(function () {
                var render = renderFunc();
                var node = guard(findOne(render, selector));
                node.children = node.children || [];
                switch (type) {
                    case 'prepend':
                        node.children = tslib_1.__spread(children, node.children);
                        break;
                    case 'append':
                        node.children = tslib_1.__spread(node.children, children);
                        break;
                    case 'replace':
                        node.children = tslib_1.__spread(children);
                        break;
                }
                return render;
            });
        };
        assertionTemplateResult.insertBefore = function (selector, children) {
            return assertionTemplateResult.insertSiblings(selector, children, 'before');
        };
        assertionTemplateResult.insertAfter = function (selector, children) {
            return assertionTemplateResult.insertSiblings(selector, children, 'after');
        };
        assertionTemplateResult.insertSiblings = function (selector, children, type) {
            if (type === void 0) { type = 'after'; }
            return assertionTemplate(function () {
                var render = renderFunc();
                var node = guard(findOne(render, selector));
                var parent = node.parent;
                var index = parent.children.indexOf(node);
                var newChildren = tslib_1.__spread(parent.children);
                switch (type) {
                    case 'before':
                        newChildren.splice.apply(newChildren, tslib_1.__spread([index, 0], children));
                        parent.children = newChildren;
                        break;
                    case 'after':
                        newChildren.splice.apply(newChildren, tslib_1.__spread([index + 1, 0], children));
                        parent.children = newChildren;
                        break;
                }
                return render;
            });
        };
        assertionTemplateResult.getProperty = function (selector, property) {
            var render = renderFunc();
            var node = guard(findOne(render, selector));
            return node.properties[property];
        };
        assertionTemplateResult.getChildren = function (selector) {
            var render = renderFunc();
            var node = guard(findOne(render, selector));
            return node.children || [];
        };
        return assertionTemplateResult;
    }
    exports.assertionTemplate = assertionTemplate;
    exports.default = assertionTemplate;
});
//# sourceMappingURL=assertionTemplate.js.map