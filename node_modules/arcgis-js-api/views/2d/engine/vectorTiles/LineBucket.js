// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/extendsHelper","../../../../core/has","../../../../symbols/cim/enums","./Bucket","./style/StyleLayer","../webgl/TurboLine","../webgl/mesh/templates/util"],function(e,r,t,n,i,x,l,s,a){var d=0,u=0,o=0;n("esri-tiles-performance")&&setInterval(function(){console.log("New (VTL)","feat="+o,"secs="+d,"tris="+u,"tris/sec="+Math.round(u/d))},1e4);var f=function(e){return function(r){r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)}},c=function(e){return function(r){e._lineIndexBuffer.add(r.leftExit0,r.rightEntry0,r.leftExit2),e._lineIndexBuffer.add(r.rightEntry0,r.rightEntry2,r.leftExit2)}},V=function(e){return function(r){var t=e._joinType===i.JoinType.MITER?e._miterLimitCosine:e._roundLimitCosine,n=r.isCap&&e._capType!==i.CapType.BUTT,x=!1;r.cosine>.97?(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues),r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues)):r.cosine<1-.97?(r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):r.canSplit?(s.splitVertex(),r.sign>0?(r.splitInner?(r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.leftInner.x,r.leftInner.y,0,-1,r.distance,e._ddValues),r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.rightInner.x,r.rightInner.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)),r.cosine<t?(x=!r.isCap,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):r.splitOuter?(x=x||r.gapOuter,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.leftOuter.x,-r.leftOuter.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.rightOuter.x,-r.rightOuter.y,0,1,r.distance,e._ddValues)):(r.entry2=r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues))):(r.splitInner?(r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.leftInner.x,-r.leftInner.y,0,1,r.distance,e._ddValues),r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.rightInner.x,-r.rightInner.y,0,1,r.distance,e._ddValues)):(r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues)),r.cosine<t?(x=!r.isCap,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues)):r.splitOuter?(x=x||r.gapOuter,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.leftOuter.x,r.leftOuter.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.rightOuter.x,r.rightOuter.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)))):r.sign>0?(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues),r.cosine<t?(x=!r.isCap,r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x,-r.prevNormal.y,0,1,r.distance,e._ddValues),r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.nextNormal.x,-r.nextNormal.y,0,1,r.distance,e._ddValues)):(r.entry2=r.exit2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues))):(r.exit2=r.entry2=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.bisector.x/r.cosine,-r.bisector.y/r.cosine,0,1,r.distance,e._ddValues),r.cosine<t?(x=!r.isCap,r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x,r.prevNormal.y,0,-1,r.distance,e._ddValues),r.exit0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.nextNormal.x,r.nextNormal.y,0,-1,r.distance,e._ddValues)):(r.exit0=r.entry0=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.bisector.x/r.cosine,r.bisector.y/r.cosine,0,-1,r.distance,e._ddValues)));var l,a=r.canSplit&&(r.splitInner||r.splitOuter);if(a||x||n?(l=r.entry1=r.exit1=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,0,0,0,0,r.distance,e._ddValues)):l=r.entry1=r.exit1=null,x&&e._joinType!==i.JoinType.ROUND)e._lineIndexBuffer.add(l,r.sign>0?r.exit2:r.entry0,r.sign>0?r.entry2:r.exit0);else if(n&&e._capType===i.CapType.ROUND||x&&e._joinType===i.JoinType.ROUND){var d=void 0,u=void 0,o=void 0,f=void 0,c=void 0,V=void 0;if(r.isCap){var _=Math.PI;c=Math.ceil(_/.8),V=_/c,r.isFirstVertex?(d=r.prevNormal.x,u=r.prevNormal.y,o=r.entry0,f=r.entry2):r.isLastVertex&&(d=-r.nextNormal.x,u=-r.nextNormal.y,o=r.exit2,f=r.exit0)}else{var _=2*Math.acos(r.cosine);c=Math.ceil(_/.8),V=_/c,d=r.sign>0?-r.prevNormal.x:r.nextNormal.x,u=r.sign>0?-r.prevNormal.y:r.nextNormal.y,o=r.sign>0?r.entry2:r.exit0,f=r.sign>0?r.exit2:r.entry0}var y=Math.cos(V),p=Math.sin(V),B=y*d-p*u,h=p*d+y*u;d=B,u=h;for(var m=void 0,v=void 0,g=0;g<c;++g){if(m=v,g<c-1)if(r.isCap){var N=r.isFirstVertex?-1:1;v=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,d,u,N,0,r.distance,e._ddValues)}else v=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,d,u,0,r.sign,r.distance,e._ddValues);e._lineIndexBuffer.add(0===g?o:m,l,g===c-1?f:v);var I=y*d-p*u,b=p*d+y*u;d=I,u=b}}else if(n&&e._capType===i.CapType.SQUARE){var E=r.isFirstVertex?1:-1,P=void 0,O=void 0;e._hasPattern?(P=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x-E*r.inbound.x,r.prevNormal.y-E*r.inbound.y,-E,-1,r.distance,e._ddValues),O=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x-E*r.inbound.x,-r.prevNormal.y-E*r.inbound.y,-E,1,r.distance,e._ddValues)):(P=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,r.prevNormal.x-E*r.inbound.x,r.prevNormal.y-E*r.inbound.y,0,-1,r.distance,e._ddValues),O=e._lineVertexBuffer.index,e._lineVertexBuffer.add(r.currentVertex.x,r.currentVertex.y,-r.prevNormal.x-E*r.inbound.x,-r.prevNormal.y-E*r.inbound.y,0,1,r.distance,e._ddValues)),E>0?(e._lineIndexBuffer.add(l,r.entry2,O),e._lineIndexBuffer.add(l,O,P),e._lineIndexBuffer.add(l,P,r.entry0)):(e._lineIndexBuffer.add(l,O,r.exit2),e._lineIndexBuffer.add(l,P,O),e._lineIndexBuffer.add(l,r.exit0,P))}}},_=function(e){return function(r){e._lineIndexBuffer.add(r.leftExit0,r.rightEntry0,null!=r.leftExit1?r.leftExit1:r.leftExit2),e._lineIndexBuffer.add(r.rightEntry0,null!=r.rightEntry1?r.rightEntry1:r.rightEntry2,null!=r.leftExit1?r.leftExit1:r.leftExit2),null!=r.leftExit1&&null!=r.rightEntry1?(e._lineIndexBuffer.add(r.leftExit1,r.rightEntry1,r.leftExit2),e._lineIndexBuffer.add(r.rightEntry1,r.rightEntry2,r.leftExit2)):null!=r.leftExit1?e._lineIndexBuffer.add(r.leftExit1,r.rightEntry2,r.leftExit2):null!=r.rightEntry1&&e._lineIndexBuffer.add(r.rightEntry1,r.rightEntry2,r.leftExit2)}};return function(e){function r(r,t,n,i){var x=e.call(this,r,t)||this;if(x._tessellationOptions={},x.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_hasPattern:null,_ddValues:null,_capType:null,_joinType:null,_miterLimitCosine:null,_roundLimitCosine:null},r.hasDataDrivenLine!==n.isDataDriven())throw new Error("incompatible line buffer");return x.tessellationProperties._lineVertexBuffer=n,x.tessellationProperties._lineIndexBuffer=i,x.tessellationProperties._hasPattern=r.getPaintValue("line-pattern",x.zoom)||r.getPaintValue("line-dasharray",x.zoom).length>0,x._isThinLine=r.isThinLine,x._isThinLine?x._tessellationCallbacks={vertex:f(x.tessellationProperties),bridge:c(x.tessellationProperties)}:x._tessellationCallbacks={vertex:V(x.tessellationProperties),bridge:_(x.tessellationProperties)},x}return t(r,e),Object.defineProperty(r.prototype,"lineIndexStart",{get:function(){return this._lineIndexStart},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"lineIndexCount",{get:function(){return this._lineIndexCount},enumerable:!0,configurable:!0}),r.prototype.assignBufferInfo=function(e){var r=e;r._lineIndexStart=this._lineIndexStart,r._lineIndexCount=this._lineIndexCount},r.prototype.processFeatures=function(e){this._lineIndexStart=this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;var r=this.layer,t=this.zoom,n=r.hasDataDrivenLine;e&&e.setExtent(this.layerExtent);for(var i=[1,1,1,1],x=1,d=1,u=0,o=this._features;u<o.length;u++){var f=o[u],c=new l.LineLayout(r,t,f);!this.tessellationProperties._hasPattern&&r.hasDataDrivenColor&&(i=r.getPaintValue("line-color",t,f)),r.hasDataDrivenOpacity&&(x=r.getPaintValue("line-opacity",t,f)),r.hasDataDrivenWidth&&(d=r.getPaintValue("line-width",t,f));var V=void 0;if(!(n&&(V={color:i,opacity:x,size:Math.max(Math.min(d,256),0)},V.size<=0||V.opacity<=0||V.color[3]<=0))){this.tessellationProperties._capType=c.cap,this.tessellationProperties._joinType=c.join,this.tessellationProperties._miterLimitCosine=a.getLimitCosine(c.miterLimit),this.tessellationProperties._roundLimitCosine=a.getLimitCosine(c.roundLimit);var _=f.getGeometry(e);this._processFeature(_,V)}}s.cleanup()},r.prototype._processFeature=function(e,r){if(e)for(var t=e.length,n=0;n<t;n++)this._processGeometry(e[n],r)},r.prototype._processGeometry=function(e,r){var t;if(n("esri-tiles-performance")&&(t=performance.now()),!(e.length<2)){for(var i,x,l=e[0],a=1;a<e.length;)i=e[a].x-l.x,x=e[a].y-l.y,i*i+x*x<1e-6?e.splice(a,1):(l=e[a],++a);if(!(e.length<2)){var f=this.tessellationProperties._lineIndexBuffer.index;this._tessellationOptions.trackDistance=this.tessellationProperties._hasPattern,this._tessellationOptions.initialDistance=0,this._tessellationOptions.thin=this._isThinLine,this._tessellationOptions.wrapDistance=65535,this._tessellationOptions.outerBisectorAutoSplitThreshold=1/3.8,this._tessellationOptions.enableOuterBisectorSplit=this.tessellationProperties._hasPattern,this._tessellationOptions.innerBisectorAutoSplitThreshold=1/3.8,this._tessellationOptions.enableInnerBisectorSplit=this.tessellationProperties._hasPattern,this.tessellationProperties._ddValues=r,s.tessellate(e,this._tessellationOptions,this._tessellationCallbacks),this._lineIndexCount+=3*(this.tessellationProperties._lineIndexBuffer.index-f),n("esri-tiles-performance")&&(d+=(performance.now()-t)/1e3,u+=this.tessellationProperties._lineIndexBuffer.index-f,o++)}}},r}(x)});