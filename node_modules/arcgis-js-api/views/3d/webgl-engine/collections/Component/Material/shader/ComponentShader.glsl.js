// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports","../../../../../../../core/tsSupport/makeTemplateObjectHelper","./ComponentData.glsl","./VertexDiscardByOpacity.glsl","../../../../core/shaderLibrary/DiscardOrAdjustAlpha.glsl","../../../../core/shaderLibrary/ForwardLinearDepth.glsl","../../../../core/shaderLibrary/Slice.glsl","../../../../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl","../../../../core/shaderLibrary/attributes/VertexColor.glsl","../../../../core/shaderLibrary/attributes/VertexNormal.glsl","../../../../core/shaderLibrary/attributes/VertexPosition.glsl","../../../../core/shaderLibrary/output/OutputDepth.glsl","../../../../core/shaderLibrary/output/OutputHighlight.glsl","../../../../core/shaderLibrary/shading/ComputeMaterialColor.glsl","../../../../core/shaderLibrary/shading/ComputeNormalTexture.glsl","../../../../core/shaderLibrary/shading/ComputeShadingNormal.glsl","../../../../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl","../../../../core/shaderLibrary/shading/ReadBaseColorTexture.glsl","../../../../core/shaderLibrary/shading/ReadShadowMap.glsl","../../../../core/shaderModules/interfaces","../../../../core/shaderModules/ShaderBuilder"],function(e,a,o,n,r,t,l,i,d,s,c,u,h,g,m,v,C,p,x,f,S,w,b){function L(e){var a=new b.ShaderBuilder;return a.include(u.VertexPosition,e),a.include(c.VertexNormal,e),a.include(s.VertexColor,e),a.include(d.TextureCoordinateAttribute,e),a.include(l.ForwardLinearDepth,e),a.include(n.ComponentData,e),a.include(t.DiscardOrAdjustAlpha,e),a.include(i.Slice,e),a.include(f.ReadBaseColorTexture,e),a.include(r.VertexDiscardByOpacity,e),e.usePBR&&(a.include(x.PhysicallyBasedRenderingParameters,e),a.include(v.ComputeNormalTexture,e)),3===e.output&&1===e.componentData?a.vertex.code.add(w.glsl(A||(A=o(["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "],["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "])))):a.vertex.code.add(w.glsl(y||(y=o(["\n      #define discardShadows(castShadows) {}\n    "],["\n      #define discardShadows(castShadows) {}\n    "])))),a.vertex.code.add(w.glsl(P||(P=o(["\n    #define SYMBOL_ALPHA_CUTOFF 0.001\n\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < SYMBOL_ALPHA_CUTOFF) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      forwardPosition();\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "],["\n    #define SYMBOL_ALPHA_CUTOFF 0.001\n\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < SYMBOL_ALPHA_CUTOFF) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      forwardPosition();\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "])))),0===e.output&&(a.include(m.ComputeMaterialColor,e),a.include(C.ComputeShadingNormal,e),a.include(p.EvaluateSceneLighting,e),e.receiveShadows?(a.include(S.ReadShadowMap,e),a.fragment.code.add(w.glsl(O||(O=o(["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "],["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "]))))):a.fragment.code.add(w.glsl(B||(B=o(["\n        float evaluateShadow() { return 0.0; }\n      "],["\n        float evaluateShadow() { return 0.0; }\n      "])))),a.fragment.code.add(w.glsl(M||(M=o(["\n      // ShaderOutput.Color\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        "],["\n      // ShaderOutput.Color\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        "])))),e.usePBR?(a.fragment.code.add(w.glsl(R||(R=o(["\n        applyPBRFactors();\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];;\n      "],["\n        applyPBRFactors();\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];;\n      "])))),a.fragment.code.add(w.glsl(W||(W=o(["\n        if (int(externalColorMixMode) == 3 /* replace */) {\n          reflectance = 0.2;\n          roughness = 0.6;\n          metalness = 0.0;\n        }\n      "],["\n        if (int(externalColorMixMode) == 3 /* replace */) {\n          reflectance = 0.2;\n          roughness = 0.6;\n          metalness = 0.0;\n        }\n      "])))),e.hasNormalTexture?a.fragment.code.add(w.glsl(D||(D=o(["\n        mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);\n        "])))):a.fragment.code.add(w.glsl(T||(T=o(["\n        vec3 shadingNormal = normalVertex;\n        "],["\n        vec3 shadingNormal = normalVertex;\n        "])))),a.fragment.code.add(w.glsl(N||(N=o(["\n        vec3 normalGround = normalize(positionWorld());\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, roughness, metalness, emission, reflectance, additionalIrradiance);\n        "],["\n        vec3 normalGround = normalize(positionWorld());\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, roughness, metalness, emission, reflectance, additionalIrradiance);\n        "]))))):(e.receiveShadows?a.fragment.code.add(w.glsl(_||(_=o(["\n      float shadow = evaluateShadow();\n        "],["\n      float shadow = evaluateShadow();\n        "])))):0===e.viewingMode?a.fragment.code.add(w.glsl(F||(F=o(["\n      float additionalAmbientScale = _oldHeuristicLighting(positionWorld());\n      float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "],["\n      float additionalAmbientScale = _oldHeuristicLighting(positionWorld());\n      float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "])))):a.fragment.code.add(w.glsl(V||(V=o(["\n      float shadow = 0.0;\n      "],["\n      float shadow = 0.0;\n      "])))),a.fragment.code.add(w.glsl(j||(j=o(["\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec3 shadedColor = evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight);\n      "],["\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec3 shadedColor = evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight);\n      "]))))),a.fragment.code.add(w.glsl(H||(H=o(["\n        gl_FragColor = highlightSlice(vec4(shadedColor, materialColor.a), vPositionWorldCameraRelative);\n      }\n    "],["\n        gl_FragColor = highlightSlice(vec4(shadedColor, materialColor.a), vPositionWorldCameraRelative);\n      }\n    "]))))),1!==e.output&&3!==e.output||(a.include(h.OutputDepth,e),a.fragment.code.add(w.glsl(I||(I=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "]))))),2===e.output&&(a.include(C.ComputeShadingNormal,e),a.fragment.code.add(w.glsl(E||(E=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), 1.0);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), 1.0);\n      }\n    "]))))),4===e.output&&(a.include(g.OutputHighlight),a.fragment.code.add(w.glsl(G||(G=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputHighlight();\n      }\n    "]))))),a}Object.defineProperty(a,"__esModule",{value:!0}),a.attributeLocations={position:0,normal:1,normalCompressed:1,color:2,uv0:3,uvRegion:4,componentIndex:5},a.build=L;var A,y,P,O,B,M,R,W,D,T,N,_,F,V,j,H,I,E,G});