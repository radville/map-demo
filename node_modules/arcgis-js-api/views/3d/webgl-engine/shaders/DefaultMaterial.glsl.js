// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../collections/Component/Material/shader/DecodeSymbolColor.glsl","../core/shaderLibrary/DiscardOrAdjustAlpha.glsl","../core/shaderLibrary/ForwardLinearDepth.glsl","../core/shaderLibrary/Offset.glsl","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/attributes/PositionAttribute.glsl","../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl","../core/shaderLibrary/attributes/VertexColor.glsl","../core/shaderLibrary/attributes/VertexNormal.glsl","../core/shaderLibrary/attributes/VerticalOffset.glsl","../core/shaderLibrary/output/OutputDepth.glsl","../core/shaderLibrary/shading/ComputeNormalTexture.glsl","../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/HighlightData.glsl","../core/shaderLibrary/shading/Normals.glsl","../core/shaderLibrary/shading/PhysicallyBasedRendering.glsl","../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl","../core/shaderLibrary/shading/ReadShadowMap.glsl","../core/shaderLibrary/shading/VisualVariables.glsl","../core/shaderLibrary/util/DoublePrecision.glsl","../core/shaderLibrary/util/MixExternalColor.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],function(o,e,a,n,l,i,r,t,d,s,c,v,m,g,u,p,h,x,f,b,y,C,O,w,P,L,D,M){function N(o){var e=new M.ShaderBuilder,N=e.vertex.code,Bo=e.fragment.code;return N.add(D.glsl(A||(A=a(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "])),JSON.stringify(o))),Bo.add(D.glsl(S||(S=a(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "])),JSON.stringify(o))),e.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),e.include(s.PositionAttribute),e.varyings.add("vpos","vec3"),e.include(w.VisualVariables,o),o.instanced&&o.instancedDoublePrecision?(e.attributes.add("modelOriginHi","vec3"),e.attributes.add("modelOriginLo","vec3"),e.attributes.add("model","mat3"),e.attributes.add("modelNormal","mat3")):(e.vertex.uniforms.add("model","mat4"),e.vertex.uniforms.add("modelNormal","mat4")),o.instancedDoublePrecision?(e.include(P.DoublePrecision,o),e.vertex.uniforms.add("viewOriginHi","vec3"),e.vertex.uniforms.add("viewOriginLo","vec3"),N.add(D.glsl(F||(F=a(["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "]))))):N.add(D.glsl(T||(T=a(["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "])))),e.include(g.VerticalOffset,o),0===o.output&&(e.include(d.Transform,{linearDepth:!1}),0===o.normalType&&o.offsetBackfaces&&e.include(r.Offset),e.include(p.ComputeNormalTexture,o),e.include(m.VertexNormal,o),o.instancedColor&&e.attributes.add("instanceColor","vec4"),e.varyings.add("localvpos","vec3"),e.include(c.TextureCoordinateAttribute,o),e.include(i.ForwardLinearDepth,o),o.symbolColor?(e.include(n.DecodeSymbolColor),e.attributes.add("symbolColor","vec4"),e.varyings.add("colorMixMode","mediump float")):e.fragment.uniforms.add("colorMixMode","int"),e.include(v.VertexColor,o),e.vertex.uniforms.add("externalColor","vec4"),e.varyings.add("vcolorExt","vec4"),e.vertex.defines.addFloat("SYMBOL_ALPHA_CUTOFF",.001),N.add(D.glsl(_||(_=a(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n    "])),o.instancedColor?"vcolorExt *= instanceColor;":"")),o.symbolColor&&N.add(D.glsl(V||(V=a(["\n        int symbolColorMixMode;\n        vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // = 1/255;\n        colorMixMode = float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "],["\n        int symbolColorMixMode;\n        vcolorExt *= decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // = 1/255;\n        colorMixMode = float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "])))),N.add(D.glsl(z||(z=a(["\n        if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n    "],["\n        if (vcolorExt.a < SYMBOL_ALPHA_CUTOFF) {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n    "])))),o.instancedDoublePrecision?(0===o.normalType&&N.add(D.glsl(E||(E=a(["\n          vNormalWorld = normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "],["\n          vNormalWorld = normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "])))),N.add(D.glsl(B||(B=a(["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -= originDelta;\n      "],["\n          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -= originDelta;\n      "]))))):0===o.normalType&&N.add(D.glsl(H||(H=a(["\n          vNormalWorld = normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n          vNormalWorld = normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "])))),N.add(D.glsl(j||(j=a(["\n          ","\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n          ","\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "])),o.verticalOffsetEnabled?"vpos += calculateVerticalOffset(vpos, localOrigin);":"",o.vertexTangets?"transformVertexTangent(mat3(modelNormal));":"",0===o.normalType&&o.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),e.include(t.Slice,o),e.include(x.EvaluateSceneLighting,o),e.include(h.EvaluateAmbientOcclusion,o),e.include(l.DiscardOrAdjustAlpha,o),o.receiveShadows&&e.include(O.ReadShadowMap,o),e.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float").add("layerOpacity","float"),o.treeRendering&&e.fragment.uniforms.add("view","mat4"),o.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),3===o.normalType&&e.extensions.add("GL_OES_standard_derivatives"),e.include(C.PhysicallyBasedRenderingParameters,o),e.include(y.PhysicallyBasedRendering,o),e.include(L.MixExternalColor,{stages:1}),e.include(b.Normals,o),Bo.add(D.glsl(R||(R=a(["\n        void main() {\n          discardBySlice(vpos);\n    "],["\n        void main() {\n          discardBySlice(vpos);\n    "])))),o.hasColorTexture?(Bo.add(D.glsl(W||(W=a(["\n          vec4 texColor = texture2D(tex, vuv0);\n      "],["\n          vec4 texColor = texture2D(tex, vuv0);\n      "])))),o.textureAlphaPremultiplied&&Bo.add(D.glsl(I||(I=a(["\n            texColor.rgb /= texColor.a;\n        "],["\n            texColor.rgb /= texColor.a;\n        "])))),Bo.add(D.glsl(k||(k=a(["\n            discardOrAdjustAlpha(texColor);\n      "],["\n            discardOrAdjustAlpha(texColor);\n      "]))))):Bo.add(D.glsl(G||(G=a(["\n            vec4 texColor = vec4(1.0);\n      "],["\n            vec4 texColor = vec4(1.0);\n      "])))),Bo.add(D.glsl(U||(U=a(["\n            shadingParams.viewDirection = normalize(vpos - camPos);\n    "],["\n            shadingParams.viewDirection = normalize(vpos - camPos);\n    "])))),3===o.normalType?Bo.add(D.glsl(Y||(Y=a(["\n        vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "],["\n        vec3 normal = normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "])))):Bo.add(D.glsl(J||(J=a(["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);\n      "],["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);\n      "])))),o.usePBR&&Bo.add(D.glsl(q||(q=a(["applyPBRFactors();"],["applyPBRFactors();"])))),Bo.add(D.glsl(K||(K=a(["\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "])))),o.receiveShadows?e.fragment.code.add(D.glsl(Q||(Q=a(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "])))):0===o.viewingMode?e.fragment.code.add(D.glsl(X||(X=a(["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "])))):e.fragment.code.add(D.glsl(Z||(Z=a(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "])))),Bo.add(D.glsl($||($=a(["\n        vec3 matColor = max(ambient, diffuse);\n    "],["\n        vec3 matColor = max(ambient, diffuse);\n    "])))),o.attributeColor?Bo.add(D.glsl(oo||(oo=a(["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "])))):(Bo.add(D.glsl(eo||(eo=a(["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "])))),o.usePBR&&Bo.add(D.glsl(ao||(ao=a(["\n          if (int(colorMixMode) == 3 /* replace */) {\n            reflectance = 0.2;\n            roughness = 0.6;\n            metalness = 0.0;\n          }\n        "],["\n          if (int(colorMixMode) == 3 /* replace */) {\n            reflectance = 0.2;\n            roughness = 0.6;\n            metalness = 0.0;\n          }\n        "]))))),o.hasNormalTexture?(o.vertexTangets?Bo.add(D.glsl(no||(no=a(["\n        mat3 tangentSpace = computeTangentSpace(normal);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normal);\n        "])))):Bo.add(D.glsl(lo||(lo=a(["\n        mat3 tangentSpace = computeTangentSpace(normal, vpos, vuv0);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normal, vpos, vuv0);\n        "])))),Bo.add(D.glsl(io||(io=a(["\n        vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);\n      "],["\n        vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);\n      "]))))):Bo.add(D.glsl(ro||(ro=a(["\n        vec3 shadedNormal = normal;\n      "],["\n        vec3 shadedNormal = normal;\n      "])))),o.treeRendering&&Bo.add(D.glsl(to||(to=a(["\n        shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;\n    "],["\n        shadedNormal = normalize(vNormalWorld);\n        albedo_ *= 1.2;\n        vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView = clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance = 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff = vColor.r;\n        float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight += backLightFactor * lightingMainIntensity;\n    "])))),o.usePBR?Bo.add(D.glsl(so||(so=a(["\n        float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround = normalize(vpos + localOrigin);\n        vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "],["\n        float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround = normalize(vpos + localOrigin);\n        vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "])))):Bo.add(D.glsl(co||(co=a(["\n        vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "],["\n        vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "])))),Bo.add(D.glsl(vo||(vo=a(["\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "]))))),1!==o.output&&3!==o.output||(e.include(d.Transform,{linearDepth:!0}),e.include(c.TextureCoordinateAttribute,o),e.include(w.VisualVariables,o),e.include(u.OutputDepth,o),e.include(t.Slice,o),e.vertex.uniforms.add("nearFar","vec2"),e.varyings.add("depth","float"),o.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),N.add(D.glsl(mo||(mo=a(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "])))),o.instancedDoublePrecision&&N.add(D.glsl(go||(go=a(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "])))),o.verticalOffsetEnabled&&N.add(D.glsl(uo||(uo=a(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "])))),N.add(D.glsl(po||(po=a(["\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "])))),e.include(l.DiscardOrAdjustAlpha,o),Bo.add(D.glsl(ho||(ho=a(["\n      void main(void) {\n        discardBySlice(vpos);\n    "],["\n      void main(void) {\n        discardBySlice(vpos);\n    "])))),o.hasColorTexture&&Bo.add(D.glsl(xo||(xo=a(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "])))),Bo.add(D.glsl(fo||(fo=a(["\n        outputDepth(depth);\n      }\n    "],["\n        outputDepth(depth);\n      }\n    "]))))),2===o.output&&(3===o.normalType&&e.extensions.add("GL_OES_standard_derivatives"),e.include(d.Transform,{linearDepth:!1}),e.include(m.VertexNormal,o),e.include(c.TextureCoordinateAttribute,o),e.include(w.VisualVariables,o),o.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),e.vertex.uniforms.add("viewNormal","mat4"),e.varyings.add("vPositionView","vec3"),N.add(D.glsl(bo||(bo=a(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "])))),o.instancedDoublePrecision?(0===o.normalType&&N.add(D.glsl(yo||(yo=a(["\n        vNormalWorld = normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "],["\n        vNormalWorld = normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "])))),N.add(D.glsl(Co||(Co=a(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "]))))):0===o.normalType&&N.add(D.glsl(Oo||(Oo=a(["\n        vNormalWorld = normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n        vNormalWorld = normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "])))),o.verticalOffsetEnabled&&N.add(D.glsl(wo||(wo=a(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "])))),N.add(D.glsl(Po||(Po=a(["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),e.include(t.Slice,o),e.include(l.DiscardOrAdjustAlpha,o),Bo.add(D.glsl(Lo||(Lo=a(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "])))),o.hasColorTexture&&Bo.add(D.glsl(Do||(Do=a(["\n          vec4 texColor = texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "],["\n          vec4 texColor = texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "])))),3===o.normalType?Bo.add(D.glsl(Mo||(Mo=a(["\n        vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "],["\n        vec3 normal = normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "])))):Bo.add(D.glsl(No||(No=a(["\n        vec3 normal = normalize(vNormalWorld);\n        if (gl_FrontFacing == false) normal = -normal;\n      "],["\n        vec3 normal = normalize(vNormalWorld);\n        if (gl_FrontFacing == false) normal = -normal;\n      "])))),Bo.add(D.glsl(Ao||(Ao=a(["\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "],["\n        gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "]))))),4===o.output&&(e.include(d.Transform,{linearDepth:!1}),e.include(c.TextureCoordinateAttribute,o),e.include(w.VisualVariables,o),o.hasColorTexture&&e.fragment.uniforms.add("tex","sampler2D"),N.add(D.glsl(So||(So=a(["\n      void main(void) {\n        vpos = calculateVPos();\n    "],["\n      void main(void) {\n        vpos = calculateVPos();\n    "])))),o.instancedDoublePrecision&&N.add(D.glsl(Fo||(Fo=a(["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "],["\n        vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -= originDelta;\n      "])))),o.verticalOffsetEnabled&&N.add(D.glsl(To||(To=a(["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos += calculateVerticalOffset(vpos, localOrigin);\n      "])))),N.add(D.glsl(_o||(_o=a(["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),e.include(t.Slice,o),e.include(l.DiscardOrAdjustAlpha,o),e.include(f.HighlightData),e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("highlightViewportPixelSz","vec4"),Bo.add(D.glsl(Vo||(Vo=a(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "])))),o.hasColorTexture&&Bo.add(D.glsl(zo||(zo=a(["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor = texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "])))),Bo.add(D.glsl(Eo||(Eo=a(["\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "],["\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "]))))),e}Object.defineProperty(e,"__esModule",{value:!0}),e.build=N;var A,S,F,T,_,V,z,E,B,H,j,R,W,I,k,G,U,Y,J,q,K,Q,X,Z,$,oo,eo,ao,no,lo,io,ro,to,so,co,vo,mo,go,uo,po,ho,xo,fo,bo,yo,Co,Oo,wo,Po,Lo,Do,Mo,No,Ao,So,Fo,To,_o,Vo,zo,Eo});