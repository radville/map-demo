// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/ForwardLinearDepth.glsl","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/attributes/PathVertexPosition.glsl","../core/shaderLibrary/output/OutputDepth.glsl","../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/HighlightData.glsl","../core/shaderLibrary/shading/Normals.glsl","../core/shaderLibrary/shading/NormalUtils.glsl","../core/shaderLibrary/shading/ReadShadowMap.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],function(a,o,n,e,i,l,r,d,t,s,c,m,g,v,h,p){function u(a){var o=new p.ShaderBuilder;return o.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("modelNormal","mat4").add("camPos","vec3").add("localOrigin","vec3"),o.varyings.add("vpos","vec3"),o.include(r.PathVertexPosition,a),0===a.output&&(o.include(l.Transform,{linearDepth:!1}),a.receiveShadows&&o.include(v.ReadShadowMap,a),o.include(e.ForwardLinearDepth,a),o.varyings.add("vnormal","vec3"),o.varyings.add("vcolor","vec4"),o.vertex.code.add(h.glsl(f||(f=n(["\n      void main() {\n        vpos = calculateVPos();\n\n        vnormal = normalize((modelNormal * localNormal()).xyz);\n\n        gl_Position = transformPosition(proj, view, vpos);\n\n        forwardLinearDepth();\n\n        vcolor = getColor();\n      }\n    "],["\n      void main() {\n        vpos = calculateVPos();\n\n        vnormal = normalize((modelNormal * localNormal()).xyz);\n\n        gl_Position = transformPosition(proj, view, vpos);\n\n        forwardLinearDepth();\n\n        vcolor = getColor();\n      }\n    "])))),o.include(i.Slice,a),o.include(s.EvaluateSceneLighting,a),o.include(t.EvaluateAmbientOcclusion,a),a.receiveShadows&&o.include(v.ReadShadowMap,a),o.include(m.Normals,a),o.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float"),o.fragment.code.add(h.glsl(b||(b=n(["\n      void main() {\n        discardBySlice(vpos);\n\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        shadingParams.normalView = vnormal;\n        vec3 normal = shadingNormal(shadingParams);\n        float ssao = evaluateAmbientOcclusionInverse();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n      void main() {\n        discardBySlice(vpos);\n\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        shadingParams.normalView = vnormal;\n        vec3 normal = shadingNormal(shadingParams);\n        float ssao = evaluateAmbientOcclusionInverse();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "])))),a.receiveShadows?o.fragment.code.add(h.glsl(w||(w=n(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "])))):0===a.viewingMode?o.fragment.code.add(h.glsl(P||(P=n(["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "])))):o.fragment.code.add(h.glsl(y||(y=n(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "])))),o.fragment.code.add(h.glsl(S||(S=n(["\n        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one\n        float combinedOpacity = vcolor.a * opacity;\n        albedo += 0.25 * specular; // don't completely ignore specular for now\n\n        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);\n        gl_FragColor = vec4(shadedColor, combinedOpacity);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one\n        float combinedOpacity = vcolor.a * opacity;\n        albedo += 0.25 * specular; // don't completely ignore specular for now\n\n        vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);\n        gl_FragColor = vec4(shadedColor, combinedOpacity);\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "]))))),1!==a.output&&3!==a.output||(o.include(l.Transform,{linearDepth:!0}),o.vertex.uniforms.add("nearFar","vec2"),o.varyings.add("depth","float"),o.vertex.code.add(h.glsl(F||(F=n(["\n        void main() {\n          vpos = calculateVPos();\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        }\n    "],["\n        void main() {\n          vpos = calculateVPos();\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        }\n    "])))),o.include(i.Slice,a),o.include(d.OutputDepth,a),o.fragment.uniforms.add("timeElapsed","float"),o.fragment.code.add(h.glsl(_||(_=n(["\n        void main() {\n          discardBySlice(vpos);\n          outputDepth(depth);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          outputDepth(depth);\n        }\n    "]))))),2===a.output&&(o.include(l.Transform,{linearDepth:!1}),o.include(g.NormalUtils,a),o.vertex.uniforms.add("viewNormal","mat4"),o.varyings.add("vnormal","vec3"),o.vertex.code.add(h.glsl(L||(L=n(["\n        void main(void) {\n          vpos = calculateVPos();\n          vnormal = normalize((viewNormal * modelNormal * localNormal()).xyz);\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = calculateVPos();\n          vnormal = normalize((viewNormal * modelNormal * localNormal()).xyz);\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),o.include(i.Slice,a),o.fragment.uniforms.add("waterColor","vec4"),o.fragment.code.add(h.glsl(x||(x=n(["\n        void main() {\n          discardBySlice(vpos);\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) normal = -normal;\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n    "],["\n        void main() {\n          discardBySlice(vpos);\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) normal = -normal;\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n    "]))))),4===a.output&&(o.include(l.Transform,{linearDepth:!1}),o.include(g.NormalUtils,a),o.vertex.uniforms.add("viewNormal","mat4"),o.varyings.add("vnormal","vec3"),o.vertex.code.add(h.glsl(D||(D=n(["\n        void main(void) {\n          vpos = calculateVPos();\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "],["\n        void main(void) {\n          vpos = calculateVPos();\n          gl_Position = transformPosition(proj, view, vpos);\n        }\n    "])))),o.include(i.Slice,a),o.include(c.HighlightData),o.fragment.uniforms.add("depthTex","sampler2D"),o.fragment.uniforms.add("highlightViewportPixelSz","vec4"),o.fragment.code.add(h.glsl(N||(N=n(["\n      void main() {\n        discardBySlice(vpos);\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "]))))),o}Object.defineProperty(o,"__esModule",{value:!0}),o.build=u;var f,b,w,P,y,S,F,_,L,x,D,N});