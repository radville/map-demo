// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/attributes/RibbonVertexPosition.glsl","../core/shaderLibrary/shading/LineStipple.glsl","../core/shaderLibrary/shading/PiUtils.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],function(e,n,t,i,o,r,s,l,a){function p(e){var n=new a.ShaderBuilder;return n.extensions.add("GL_OES_standard_derivatives"),n.include(s.PiUtils),n.include(o.RibbonVertexPosition,e),n.include(r.LineStipple,e),n.vertex.uniforms.add("proj","mat4").add("view","mat4").add("model","mat4").add("nearPlane","float").add("pixelRatio","float").add("miterLimit","float").add("screenSize","vec2"),n.attributes.add("position","vec3"),n.attributes.add("subdivisionFactor","float"),n.attributes.add("uv0","vec2"),n.attributes.add("auxpos1","vec3"),n.attributes.add("auxpos2","vec3"),n.varyings.add("vColor","vec4"),n.varyings.add("vpos","vec3"),n.vertex.code.add(l.glsl(c||(c=t(["\n\t\t#define PERPENDICULAR(v) vec2(v.y, -v.x);\n\t\t#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\n\n\t\tfloat interp(float ncp, vec4 a, vec4 b) {\n\t\t\treturn (-ncp - a.z) / (b.z - a.z);\n\t\t}\n\n\t\tvec2 rotate(vec2 v, float a) {\n\t\t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n\t\t\tmat2 m = mat2(c, -s, s, c);\n\t\t\treturn m * v;\n\t\t}\n"],["\n\t\t#define PERPENDICULAR(v) vec2(v.y, -v.x);\n\t\t#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y > 0.0\n\n\t\tfloat interp(float ncp, vec4 a, vec4 b) {\n\t\t\treturn (-ncp - a.z) / (b.z - a.z);\n\t\t}\n\n\t\tvec2 rotate(vec2 v, float a) {\n\t\t\tfloat s = sin(a);\n\t\t\tfloat c = cos(a);\n\t\t\tmat2 m = mat2(c, -s, s, c);\n\t\t\treturn m * v;\n\t\t}\n"])))),n.vertex.code.add(l.glsl(d||(d=t(["\n    vec4 projectAndScale(vec4 pos) {\n      vec4 posNdc = proj * pos;\n\n      // Note that posNdc is in -1:1, scaling by screenSize converts this to a coordinate system\n      // that is twice scaled (going from -size:size).\n      posNdc.xy *= screenSize / posNdc.w;\n      return posNdc;\n    }\n"],["\n    vec4 projectAndScale(vec4 pos) {\n      vec4 posNdc = proj * pos;\n\n      // Note that posNdc is in -1:1, scaling by screenSize converts this to a coordinate system\n      // that is twice scaled (going from -size:size).\n      posNdc.xy *= screenSize / posNdc.w;\n      return posNdc;\n    }\n"])))),n.vertex.code.add(l.glsl(v||(v=t(["\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearPlane*0.99;\n\n      //current pos behind ncp --\x3e we need to clip\n      if(pos.z > -nearPlane) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -nearPlane) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -nearPlane) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -nearPlane) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -nearPlane) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n"],["\n    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {\n      float vnp = nearPlane*0.99;\n\n      //current pos behind ncp --\x3e we need to clip\n      if(pos.z > -nearPlane) {\n        if (!isStartVertex) {\n          //previous in front of ncp\n          if(prev.z < -nearPlane) {\n            pos = mix(prev, pos, interp(vnp, prev, pos));\n            next = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n        //next in front of ncp\n        if(isStartVertex) {\n          if(next.z < -nearPlane) {\n            pos = mix(pos, next, interp(vnp, pos, next));\n            prev = pos;\n          } else {\n            pos = vec4(0.0, 0.0, 0.0, 1.0);\n          }\n        }\n      } else {\n        //current position visible\n        //previous behind ncp\n        if (prev.z > -nearPlane) {\n          prev = mix(pos, prev, interp(vnp, pos, prev));\n        }\n        //next behind ncp\n        if (next.z > -nearPlane) {\n          next = mix(next, pos, interp(vnp, next, pos));\n        }\n      }\n\n      pos = projectAndScale(pos);\n      next = projectAndScale(next);\n      prev = projectAndScale(prev);\n    }\n"])))),n.vertex.code.add(l.glsl(m||(m=t(["\n  void main(void) {\n    float coverage = 1.0;\n    vpos = (model * vec4(position, 1.0)).xyz;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n      bool isJoin = abs(uv0.y)-3.0 < 0.0;\n\n      float lineWidth = getSize() * pixelRatio;\n\n      // convert sub-pixel coverage to alpha\n      if( lineWidth<1.0 ){\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }\n\n      vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n      vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n      vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  "],["\n  void main(void) {\n    float coverage = 1.0;\n    vpos = (model * vec4(position, 1.0)).xyz;\n\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;\n      bool isJoin = abs(uv0.y)-3.0 < 0.0;\n\n      float lineWidth = getSize() * pixelRatio;\n\n      // convert sub-pixel coverage to alpha\n      if( lineWidth<1.0 ){\n        coverage = lineWidth;\n        lineWidth = 1.0;\n      }\n\n      vec4 pos  = view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\n      vec4 prev = view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\n      vec4 next = view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\n\n      clipAndTransform(pos, prev, next, isStartVertex);\n\n      vec2 left = (pos.xy - prev.xy);\n      vec2 right = (next.xy - pos.xy);\n\n      float leftLen = length(left);\n      float rightLen = length(right);\n  "])))),e.stippleEnabled&&n.vertex.code.add(l.glsl(f||(f=t(["\n      // uv0.x is either 0 or 1, depending on whether this is considered the start of a line segment\n      // or the end. If start, then use pos->next, otherwise use prev->pos to define the line segment\n      // vector\n      vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\n      vec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\n\n      // Scale s.t. it's in units of stipple pattern size.\n      vec2 stippleSegmentDirection = stippleSegmentInfo.zw;\n    "],["\n      // uv0.x is either 0 or 1, depending on whether this is considered the start of a line segment\n      // or the end. If start, then use pos->next, otherwise use prev->pos to define the line segment\n      // vector\n      vec4 stippleSegmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), uv0.x);\n      vec2 stippleSegmentOrigin = stippleSegmentInfo.xy;\n\n      // Scale s.t. it's in units of stipple pattern size.\n      vec2 stippleSegmentDirection = stippleSegmentInfo.zw;\n    "])))),n.vertex.code.add(l.glsl(h||(h=t(['\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n\n    if (isJoin) {\n\n      // JOIN handling ---------------------------------------------------\n      // determine if vertex is on the "outside or "inside" of the join\n      bool isOutside = ISOUTSIDE;\n\n      // compute miter join position first\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      // computer miter stretch\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n\n        // limit displacement of inner vertices\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n    '],['\n    left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);\n    right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);\n\n    vec2 capDisplacementDir = vec2(0, 0);\n    vec2 joinDisplacementDir = vec2(0, 0);\n    float displacementLen = lineWidth;\n\n    if (isJoin) {\n\n      // JOIN handling ---------------------------------------------------\n      // determine if vertex is on the "outside or "inside" of the join\n      bool isOutside = ISOUTSIDE;\n\n      // compute miter join position first\n      joinDisplacementDir = normalize(left + right);\n      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n\n      // computer miter stretch\n      if (leftLen > 0.001 && rightLen > 0.001) {\n        float nDotSeg = dot(joinDisplacementDir, left);\n        displacementLen /= length(nDotSeg*left - joinDisplacementDir);\n\n        // limit displacement of inner vertices\n        if (!isOutside) {\n          displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\n        }\n      }\n\n      if (isOutside && (displacementLen > miterLimit*lineWidth)) {\n    '])))),e.roundJoins?n.vertex.code.add(l.glsl(g||(g=t(["\n        vec2 startDir;\n        vec2 endDir;\n\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);\n      "],["\n        vec2 startDir;\n        vec2 endDir;\n\n        if (leftLen < 0.001) {\n          startDir = right;\n        }\n        else{\n          startDir = left;\n        }\n        startDir = normalize(startDir);\n        startDir = PERPENDICULAR(startDir);\n\n        if (rightLen < 0.001) {\n          endDir = left;\n        }\n        else{\n          endDir = right;\n        }\n        endDir = normalize(endDir);\n        endDir = PERPENDICULAR(endDir);\n\n        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));\n        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);\n      "])))):n.vertex.code.add(l.glsl(D||(D=t(["\n        // convert to bevel join if miterLimit is exceeded\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n  "],["\n        // convert to bevel join if miterLimit is exceeded\n        if (leftLen < 0.001) {\n          joinDisplacementDir = right;\n        }\n        else if (rightLen < 0.001) {\n          joinDisplacementDir = left;\n        }\n        else {\n          joinDisplacementDir = isStartVertex ? right : left;\n        }\n        joinDisplacementDir = normalize(joinDisplacementDir);\n        joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n  "])))),n.vertex.code.add(l.glsl(x||(x=t(["\n        displacementLen = lineWidth;\n      }\n    } else {\n    // CAP handling ---------------------------------------------------\n    if (leftLen < 0.001) {\n      joinDisplacementDir = right;\n    }\n    else if (rightLen < 0.001) {\n      joinDisplacementDir = left;\n    }\n    else {\n      joinDisplacementDir = isStartVertex ? right : left;\n    }\n    joinDisplacementDir = normalize(joinDisplacementDir);\n    joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n    displacementLen = lineWidth;\n\n    capDisplacementDir = isStartVertex ? -right : left;\n  "],["\n        displacementLen = lineWidth;\n      }\n    } else {\n    // CAP handling ---------------------------------------------------\n    if (leftLen < 0.001) {\n      joinDisplacementDir = right;\n    }\n    else if (rightLen < 0.001) {\n      joinDisplacementDir = left;\n    }\n    else {\n      joinDisplacementDir = isStartVertex ? right : left;\n    }\n    joinDisplacementDir = normalize(joinDisplacementDir);\n    joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);\n    displacementLen = lineWidth;\n\n    capDisplacementDir = isStartVertex ? -right : left;\n  "])))),e.roundCaps?n.vertex.code.add(l.glsl(u||(u=t(["\n    float angle = subdivisionFactor*PI*0.5;\n    joinDisplacementDir *= cos(angle);\n    capDisplacementDir *= sin(angle);\n    "],["\n    float angle = subdivisionFactor*PI*0.5;\n    joinDisplacementDir *= cos(angle);\n    capDisplacementDir *= sin(angle);\n    "])))):n.vertex.code.add(l.glsl(S||(S=t(["\n    capDisplacementDir *= subdivisionFactor;\n    "],["\n    capDisplacementDir *= subdivisionFactor;\n    "])))),n.vertex.code.add(l.glsl(L||(L=t(["\n  }\n\n  pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n  pos.xy += capDisplacementDir * displacementLen;\n  "],["\n  }\n\n  pos.xy += joinDisplacementDir * sign(uv0.y) * displacementLen;\n  pos.xy += capDisplacementDir * displacementLen;\n  "])))),e.stippleEnabled&&(n.vertex.code.add(l.glsl(b||(b=t(["\n    {\n      // Compute the stipple pattern UV coordinate from the actual position, based on the origin\n      // and direction of the line segment on which the stipple pattern is based.\n\n      // Project the vector from the origin of the segment to the vertex onto the line segment.\n      // Note the 0.5 factor due to projected positions being at twice the screen size scale (see projectAndScale)\n      vec2 posVec = pos.xy - stippleSegmentOrigin;\n\n      float stippleSegmentDirectionLength = length(stippleSegmentDirection);\n    "],["\n    {\n      // Compute the stipple pattern UV coordinate from the actual position, based on the origin\n      // and direction of the line segment on which the stipple pattern is based.\n\n      // Project the vector from the origin of the segment to the vertex onto the line segment.\n      // Note the 0.5 factor due to projected positions being at twice the screen size scale (see projectAndScale)\n      vec2 posVec = pos.xy - stippleSegmentOrigin;\n\n      float stippleSegmentDirectionLength = length(stippleSegmentDirection);\n    "])))),e.stippleIntegerRepeatsEnabled&&n.vertex.code.add(l.glsl(P||(P=t(["\n      float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\n      float roundedNumberOfPatternRepeats = max(1.0, floor(numberOfPatternRepeats + 0.5));\n      stipplePatternUvMax = roundedNumberOfPatternRepeats;\n      "],["\n      float numberOfPatternRepeats = stippleSegmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;\n      float roundedNumberOfPatternRepeats = max(1.0, floor(numberOfPatternRepeats + 0.5));\n      stipplePatternUvMax = roundedNumberOfPatternRepeats;\n      "])))),n.vertex.code.add(l.glsl(y||(y=t(["\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ","\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    "],["\n      if (stippleSegmentDirectionLength >= 0.001) {\n        // Project the vertex position onto the line segment.\n        float projectedLength = dot(stippleSegmentDirection, posVec) / stippleSegmentDirectionLength * 0.5;\n     ","\n        stipplePatternUv = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;\n        } else {\n          stipplePatternUv = 1.0;\n        }\n      }\n    "])),e.stippleIntegerRepeatsEnabled?"float wholeNumberOfRepeatsScale = roundedNumberOfPatternRepeats / numberOfPatternRepeats;":"float wholeNumberOfRepeatsScale = 1.0;"))),n.vertex.code.add(l.glsl(j||(j=t(["\n      // Convert back into NDC\n      pos.xy = pos.xy / screenSize * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      gl_Position = pos;\n    }\n  }\n  "],["\n      // Convert back into NDC\n      pos.xy = pos.xy / screenSize * pos.w;\n\n      vColor = getColor();\n      vColor.a *= coverage;\n\n      gl_Position = pos;\n    }\n  }\n  "])))),n.include(i.Slice,e),0===e.output&&(n.fragment.uniforms.add("symbolColor","vec4"),n.fragment.code.add(l.glsl(z||(z=t(["\n    void main() {\n      discardBySlice(vpos);\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n      vec4 color = symbolColor * vColor;\n      gl_FragColor = highlightSlice(blendStipple(color, stippleAlpha), vpos);\n    }\n    "],["\n    void main() {\n      discardBySlice(vpos);\n      float stippleAlpha = getStippleAlpha();\n      discardByStippleAlpha(stippleAlpha, STIPPLE_ALPHA_COLOR_DISCARD);\n      vec4 color = symbolColor * vColor;\n      gl_FragColor = highlightSlice(blendStipple(color, stippleAlpha), vpos);\n    }\n    "]))))),4===e.output&&n.fragment.code.add(l.glsl(A||(A=t(["\n      void main() {\n        discardBySlice(vpos);\n        discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        discardByStippleAlpha(getStippleAlpha(), STIPPLE_ALPHA_HIGHLIGHT_DISCARD);\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n    "])))),n}Object.defineProperty(n,"__esModule",{value:!0}),n.build=p;var c,d,v,m,f,h,g,D,x,u,S,L,b,P,y,j,z,A});