// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/output/OutputDepth.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/HighlightData.glsl","../core/shaderLibrary/shading/NormalUtils.glsl","../core/shaderLibrary/util/RgbaFloatEncoding.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder","./Overlay.glsl","./Skirts.glsl"],function(e,n,o,a,r,l,i,t,v,s,c,d,g,m){function p(e){var n=new d.ShaderBuilder;return n.include(m.Skirts),n.attributes.add("position","vec3"),n.attributes.add("uv0","vec2"),n.vertex.uniforms.add("proj","mat4").add("view","mat4").add("origin","vec3").add("skirtScale","float"),0===e.output&&(n.include(r.Transform,{linearDepth:!1}),n.include(v.NormalUtils,e),e.overlayEnabled&&n.include(g.Overlay,{usePBR:!1,usePBRforWater:!0,useCustomDTRExponentForWater:!1}),n.varyings.add("vnormal","vec3"),n.varyings.add("vpos","vec3"),n.varyings.add("vtc","vec2"),n.vertex.uniforms.add("viewNormal","mat4"),n.vertex.uniforms.add("texOffsetAndScale","vec4"),e.receiveShadows&&n.varyings.add("linearDepth","float"),e.tileBorders&&n.varyings.add("vuv","vec2"),e.atmosphere&&(n.vertex.uniforms.add("lightingMainDirection","vec3"),n.varyings.add("wnormal","vec3"),n.varyings.add("wlight","vec3")),e.overlayEnabled&&(n.varyings.add("tbnTangent","vec3"),n.varyings.add("tbnBiTangent","vec3")),e.screenSizePerspective&&(n.vertex.uniforms.add("screenSizePerspective","vec4"),n.varyings.add("screenSizeDistanceToCamera","float"),n.varyings.add("screenSizeCosAngle","float")),n.vertex.code.add(c.glsl(f||(f=o(["\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n      "],["\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n      "])))),e.atmosphere&&n.vertex.code.add(c.glsl(u||(u=o(["\n        wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight = (view  * vec4(-lightingMainDirection, 1.0)).xyz;\n      "],["\n        wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight = (view  * vec4(-lightingMainDirection, 1.0)).xyz;\n      "])))),e.tileBorders&&n.vertex.code.add(c.glsl(h||(h=o(["\n        vuv = uv;\n      "],["\n        vuv = uv;\n      "])))),e.screenSizePerspective&&n.vertex.code.add(c.glsl(C||(C=o(["\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);\n      "],["\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);\n      "])))),n.vertex.code.add(c.glsl(b||(b=o(["\n        gl_Position = transformPosition(proj, view, vpos);\n      "],["\n        gl_Position = transformPosition(proj, view, vpos);\n      "])))),e.receiveShadows&&n.vertex.code.add(c.glsl(w||(w=o(["\n        linearDepth = gl_Position.w;\n      "],["\n        linearDepth = gl_Position.w;\n      "])))),n.vertex.code.add(c.glsl(x||(x=o(["\n        vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n      "],["\n        vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n      "])))),e.overlayEnabled&&(n.vertex.code.add(c.glsl(y||(y=o(["\n        setOverlayVTC(uv);\n      "],["\n        setOverlayVTC(uv);\n      "])))),0===e.viewingMode?n.vertex.code.add(c.glsl(S||(S=o(["\n          tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n          tbnBiTangent = normalize(cross(vnormal, tbnTangent));\n          "],["\n          tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n          tbnBiTangent = normalize(cross(vnormal, tbnTangent));\n          "])))):n.vertex.code.add(c.glsl(z||(z=o(["\n          tbnTangent = vec3(1.0, 0.0, 0.0);\n          tbnBiTangent = normalize(cross(vnormal, tbnTangent));\n        "],["\n          tbnTangent = vec3(1.0, 0.0, 0.0);\n          tbnBiTangent = normalize(cross(vnormal, tbnTangent));\n        "]))))),n.vertex.code.add(c.glsl(F||(F=o(["\n      }\n    "],["\n      }\n    "])))),n.extensions.add("GL_OES_standard_derivatives"),n.extensions.add("GL_EXT_shader_texture_lod"),n.include(a.Slice,e),n.include(i.EvaluateSceneLighting,e),n.fragment.uniforms.add("camPos","vec3").add("viewDirection","vec3").add("ssaoTex","sampler2D").add("viewportPixelSz","vec4").add("tex","sampler2D").add("opacity","float"),e.screenSizePerspective&&n.fragment.uniforms.add("screenSizePerspective","vec4"),n.fragment.code.add(c.glsl(_||(_=o(["\n      const vec3 ambient = vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse = vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness = 2.5;\n      const float sliceOpacity = 0.2;\n    "],["\n      const vec3 ambient = vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse = vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness = 2.5;\n      const float sliceOpacity = 0.2;\n    "])))),e.overlayEnabled&&(n.fragment.uniforms.add("ovInnerWaterTex","sampler2D"),n.fragment.uniforms.add("ovOuterWaterTex","sampler2D")),n.fragment.code.add(c.glsl(P||(P=o(["\n      float lum(vec3 c) {\n        float max = max(max(c.r, c.g), c.b);\n        float min = min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "],["\n      float lum(vec3 c) {\n        float max = max(max(c.r, c.g), c.b);\n        float min = min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "])))),e.atmosphere&&n.fragment.code.add(c.glsl(D||(D=o(["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   = vec3(0.0);\n        vec3 fuzzySpecColor = vec3(1.0);\n        vec3 subColor       = vec3(0.0);\n        float rollOff       = 1.0;\n\n        vec3 Ln = normalize(lightPos);\n        vec3 Nn = normalize(normal);\n        vec3 Hn = normalize(view + Ln);\n\n        float ldn = dot(Ln, Nn);\n        float diffComp = max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv = dot(view, Ln);\n\n        vec3 diffContrib = surfaceColor * diffComp;\n        float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib = subLamb * subColor;\n        vec3 vecColor = vec3(vdn);\n\n        vec3 diffuseContrib = (subContrib + diffContrib);\n        vec3 specularContrib = (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "],["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   = vec3(0.0);\n        vec3 fuzzySpecColor = vec3(1.0);\n        vec3 subColor       = vec3(0.0);\n        float rollOff       = 1.0;\n\n        vec3 Ln = normalize(lightPos);\n        vec3 Nn = normalize(normal);\n        vec3 Hn = normalize(view + Ln);\n\n        float ldn = dot(Ln, Nn);\n        float diffComp = max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv = dot(view, Ln);\n\n        vec3 diffContrib = surfaceColor * diffComp;\n        float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib = subLamb * subColor;\n        vec3 vecColor = vec3(vdn);\n\n        vec3 diffuseContrib = (subContrib + diffContrib);\n        vec3 specularContrib = (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "])))),n.fragment.code.add(c.glsl(T||(T=o(["\n      void main() {\n      "],["\n      void main() {\n      "])))),e.receiveShadows?n.fragment.code.add(c.glsl(O||(O=o(["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow = readShadowMap(vpos, linearDepth);\n      "])))):n.fragment.code.add(c.glsl(L||(L=o(["\n        float shadow = 0.0;\n      "],["\n        float shadow = 0.0;\n      "])))),n.fragment.code.add(c.glsl(k||(k=o(["\n        float vndl = dot(normalize(vnormal), -lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n\n        vec4 tileColor = texture2D(tex, vtc) * opacity;\n      "],["\n        float vndl = dot(normalize(vnormal), -lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n\n        vec4 tileColor = texture2D(tex, vtc) * opacity;\n      "])))),e.overlayEnabled&&n.fragment.code.add(c.glsl(N||(N=o(["\n        vec4 overlayColor = getCombinedOverlayColor();\n        tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;\n      "],["\n        vec4 overlayColor = getCombinedOverlayColor();\n        tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;\n      "])))),n.fragment.code.add(c.glsl(M||(M=o(["\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n      "],["\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n      "])))),e.atmosphere&&n.fragment.code.add(c.glsl(B||(B=o(["\n        float ndotl = max(0.0, min(1.0, vndl));\n        atm = atmosphere(wlight, wnormal, -viewDirection);\n        atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n        atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n        atm *= tileColor.a; // premultiply with tile alpha\n      "],["\n        float ndotl = max(0.0, min(1.0, vndl));\n        atm = atmosphere(wlight, wnormal, -viewDirection);\n        atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n        atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n        atm *= tileColor.a; // premultiply with tile alpha\n      "])))),n.fragment.code.add(c.glsl(W||(W=o(["\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n      "],["\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n      "])))),e.overlayEnabled&&n.fragment.code.add(c.glsl(A||(A=o(["\n        vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n\n        float waterNormalLength = length(overlayWaterMask);\n        if (waterNormalLength > 0.95) {\n          mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n          vec4 waterColor = overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n          // un-gamma the ground color to mix in linear space\n          vec4 groundColor = vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n          waterColor = mix(groundColor, waterColor, waterColor.a);\n          gl_FragColor = delinearizeGamma(waterColor);\n        }\n      "],["\n        vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n\n        float waterNormalLength = length(overlayWaterMask);\n        if (waterNormalLength > 0.95) {\n          mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n          vec4 waterColor = overlayOpacity * getOverlayWaterColor(tileColor, overlayWaterMask, overlayColor, vpos, shadow, vnormal, camPos, tbnMatrix);\n          // un-gamma the ground color to mix in linear space\n          vec4 groundColor = vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n          waterColor = mix(groundColor, waterColor, waterColor.a);\n          gl_FragColor = delinearizeGamma(waterColor);\n        }\n      "])))),e.screenSizePerspective&&n.fragment.code.add(c.glsl(E||(E=o(["\n        float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n        if (perspectiveScale <= 0.25) {\n          gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n        }\n        else if (perspectiveScale <= 0.5) {\n          gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n        }\n        else if (perspectiveScale >= 0.99) {\n          gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n        }\n        else {\n          gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n        }\n      "],["\n        float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n        if (perspectiveScale <= 0.25) {\n          gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n        }\n        else if (perspectiveScale <= 0.5) {\n          gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n        }\n        else if (perspectiveScale >= 0.99) {\n          gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n        }\n        else {\n          gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n        }\n      "])))),e.tileBorders&&n.fragment.code.add(c.glsl(j||(j=o(["\n        vec2 dVuv = fwidth(vuv);\n        vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n        float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n\n        gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n      "],["\n        vec2 dVuv = fwidth(vuv);\n        vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n        float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n\n        gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\n      "])))),n.fragment.code.add(c.glsl(U||(U=o(["\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "]))))),1!==e.output&&3!==e.output||(n.include(r.Transform,{linearDepth:!0}),n.include(s.RgbaFloatEncoding),n.include(l.OutputDepth,{output:e.output}),n.include(v.NormalUtils,e),n.varyings.add("linearDepth","float"),n.vertex.uniforms.add("nearFar","vec2"),n.vertex.code.add(c.glsl(H||(H=o(["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "],["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "])))),n.fragment.code.add(c.glsl(V||(V=o(["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "],["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "]))))),2===e.output&&(n.include(r.Transform,{linearDepth:!1}),n.include(v.NormalUtils,e),n.varyings.add("vnormal","vec3"),n.varyings.add("vpos","vec3"),n.vertex.uniforms.add("viewNormal","mat4"),n.vertex.code.add(c.glsl(R||(R=o(["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vpos = applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position = transformPosition(proj, view, vpos);\n          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "],["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vpos = applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position = transformPosition(proj, view, vpos);\n          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "])))),n.fragment.code.add(c.glsl(G||(G=o(["\n        void main() {\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n    "],["\n        void main() {\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n    "])))),e.alphaZero?n.fragment.code.add(c.glsl(I||(I=o(["\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n      "],["\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n      "])))):n.fragment.code.add(c.glsl(q||(q=o(["\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      "],["\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      "])))),n.fragment.code.add(c.glsl(X||(X=o(["\n        }\n    "],["\n        }\n    "]))))),4===e.output&&(n.include(r.Transform,{linearDepth:!1}),n.include(v.NormalUtils,e),n.include(g.Overlay,{usePBR:!1,usePBRforWater:!1}),n.vertex.code.add(c.glsl(Z||(Z=o(["\n          void main() {\n            vec3 vnormal = getLocalUp(position, origin);\n            vec2 uv = uv0;\n            vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position = transformPosition(proj, view, vpos);\n          }\n      "],["\n          void main() {\n            vec3 vnormal = getLocalUp(position, origin);\n            vec2 uv = uv0;\n            vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position = transformPosition(proj, view, vpos);\n          }\n      "])))),n.include(t.HighlightData),n.fragment.uniforms.add("depthTex","sampler2D"),n.fragment.uniforms.add("highlightViewportPixelSz","vec4"),n.fragment.code.add(c.glsl(J||(J=o(["\n        void main() {\n          vec4 overlayColor = getCombinedOverlayColor();\n\n          if (overlayColor.a == 0.0) {\n            // Here we have to write black, instead of discarding the fragment in order to overwrite\n            // the highlights which might have been written by skirts of other tiles.\n            // As a consequence skirts are not visible, but terrain overwrites draped highlights.\n            gl_FragColor = vec4(0.0);\n            return;\n          }\n\n          gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n        }\n      "],["\n        void main() {\n          vec4 overlayColor = getCombinedOverlayColor();\n\n          if (overlayColor.a == 0.0) {\n            // Here we have to write black, instead of discarding the fragment in order to overwrite\n            // the highlights which might have been written by skirts of other tiles.\n            // As a consequence skirts are not visible, but terrain overwrites draped highlights.\n            gl_FragColor = vec4(0.0);\n            return;\n          }\n\n          gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n        }\n      "]))))),n}Object.defineProperty(n,"__esModule",{value:!0}),n.build=p;var f,u,h,C,b,w,x,y,S,z,F,_,P,D,T,O,L,k,N,M,B,W,A,E,j,U,H,V,R,G,I,q,X,Z,J});