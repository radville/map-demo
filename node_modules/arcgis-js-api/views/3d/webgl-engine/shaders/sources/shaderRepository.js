// COPYRIGHT Â© 2019 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.14/esri/copyright.txt for details.

define(["require","exports"],function(e,n){return{environment:{"realisticAtmosphere.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform vec3 lightingMainDirection;\nuniform vec3 invWavelength;\nuniform vec3 invWavelengthScaled;\nconst float krESun = 0.075;\nconst float kmESun = 0.015;\nuniform vec2 radii;\n#define innerRadius radii[0]\n#define outerRadius radii[1]\nuniform vec4 atmosParams1;\nuniform vec4 atmosParams2;\n#define shellScale atmosParams1.x\n#define shellDepth vec2(atmosParams1.y, atmosParams2.y)\n#define scaleOverScaleDepth vec2(atmosParams1.z, atmosParams2.z)\n#define oneOverScaleDepth vec2(atmosParams1.w, atmosParams2.w)\n#ifndef HAZE\nuniform vec3 atmosParams3;\nuniform float innerFadeDistance;\nuniform float altitudeFade;\n#define g atmosParams2.x\n#define gSq atmosParams3.x\n#define miePhaseCoefficients atmosParams3.y\n#define lowerAlphaBlendBound atmosParams3.z\n#endif\nuniform vec3 cameraPosition;\nuniform vec2 nearFar;\nuniform vec4 sphereComp;\n#define cameraHeight sphereComp[0]\n#define cameraHeightSq sphereComp[1]\n#define C sphereComp[2]\n#define CSur sphereComp[3]\n#ifdef HAZE\nconst float exposure = 1.5;\n#else\nconst float exposure = 2.0;\n#endif\n#ifdef HAZE\nuniform sampler2D depthTex;\n#endif\nvarying vec3 eyeDir;\nvarying vec3 worldRay;\nvarying vec2 vtc;\nconst float samples = 5.0;\nconst int maxSamples = 5;\n#ifdef HAZE\n  const vec3 oneOverGamma = vec3(1.0);\n#else\n  const vec3 oneOverGamma = vec3(0.454545);\n#endif\nvec3 expTM(vec3 inputColor,float _exposure) {\n    return pow(1.0 - exp(inputColor * -_exposure), oneOverGamma);\n}\n#ifndef HAZE\nvec3 reinhardTM(vec3 inputColor, float _exposure) {\n  vec3 intermediate = inputColor * _exposure;\n  intermediate /= ( 1.0 + intermediate );\n  return pow(intermediate, oneOverGamma);\n}\n#endif\nfloat scale(float _cos) {\n  float x = 1.0 - _cos;\n  return exp( -0.00287 + x * ( 0.459 + x * ( 3.83 + x * (-6.80 + x * 5.25 ))));\n}\nvoid main() {\n  vec3 worldSpaceRay = normalize(worldRay);\n  float B = 2.0 * dot(cameraPosition, worldSpaceRay);\n  float det = B * B - 4.0 * C;\n  float detSur = B * B - 4.0 * CSur;\n  float minRayStart = 0.0;\n#ifndef HAZE\n  float surfaceBlend = 0.0;\n  vec4 surfaceColor = vec4(0.0);\n  if (detSur >= 0.0) {\n    float nearSurface = max(0.0, 0.5 *(-B - sqrt(detSur)));\n    float farSurface = max(0.0, 0.5 *(-B + sqrt(detSur)));\n    if (nearSurface == 0.0) {\n      minRayStart = farSurface;\n    }\n    vec3 vPos = cameraPosition + worldSpaceRay * nearSurface;\n    float lightAngle = dot(-lightingMainDirection, normalize(vPos));\n    float brightness = max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)));\n    surfaceColor = vec4(brightness, brightness, brightness, 1.0 - altitudeFade);\n    float relDist = (farSurface - nearSurface) / innerFadeDistance;\n    if (relDist > 1.0) {\n      gl_FragColor = surfaceColor;\n      return;\n    }\n    surfaceBlend = smoothstep(0.0, 1.0, relDist * relDist);\n  }\n#endif\n  if (det >= 0.0) {\n#ifdef HAZE\n    float depthSample = texture2D(depthTex, vtc).r;\n    float zNear = nearFar[0];\n    float zFar = nearFar[1];\n    float zNorm = 2.0 * depthSample - 1.0;\n    float linDepth = 2.0 * zNear * zFar /\n      (zFar + zNear - zNorm * (zFar - zNear));\n    float rayEnd;\n    float altitudeAlpha = 1.0;\n    if (depthSample < 1.0 && depthSample > 0.0) {\n      vec3 cameraSpaceRay = normalize(eyeDir);\n      cameraSpaceRay /= cameraSpaceRay.z;\n      cameraSpaceRay *= linDepth;\n      float cameraSpaceRayLength = length(cameraSpaceRay);\n      vec3 world = cameraPosition + worldSpaceRay * cameraSpaceRayLength;\n      float worldRadiusSq = dot(world, world);\n      float transitionStart = innerRadius + 20000.0;\n      float transitionHeight = 25000.0;\n      float transitionEnd = transitionStart + transitionHeight;\n      float edge0 = transitionStart * transitionStart;\n      float edge1 = transitionEnd * transitionEnd;\n      altitudeAlpha = 1.0 - clamp((worldRadiusSq - edge0) / (edge1 - edge0), 0.0, 1.0);\n      rayEnd = cameraSpaceRayLength;\n      if (altitudeAlpha > 0.0 && detSur > 0.0) {\n        float nearSurface = 0.5 * ( -B - sqrt(detSur) );\n        float interp = clamp(((cameraHeight - innerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\n        rayEnd = mix(cameraSpaceRayLength, nearSurface, interp);\n      }\n    }\n#endif\n    float rayStart = 0.5 *(-B - sqrt(det));\n#ifdef HAZE\n    float near = abs(rayStart);\n    float far = abs(rayEnd);\n#else\n    float rayEnd = 0.5 *(-B + sqrt(det));\n#endif\n    float scatterDistance;\n    if (rayStart < minRayStart)\n    {\n      rayStart = minRayStart;\n#ifndef HAZE\n      scatterDistance = shellScale * min(0.0, innerRadius - cameraHeight);\n#endif\n    }\n#ifndef HAZE\n    else\n    {\n      scatterDistance = -1.0;\n    }\n#endif\n    vec3 start = cameraPosition + worldSpaceRay * rayStart;\n#ifdef HAZE\n    vec3 end = cameraPosition + worldSpaceRay * rayEnd;\n    float endLength = length(end);\n    float altitudeEnd = endLength - innerRadius;\n    float altitudeStart = length(start) - innerRadius;\n    if (altitudeStart < 0.0) {\n      altitudeStart = -altitudeStart;\n      altitudeEnd = -altitudeEnd;\n    }\n    float lightAngle = dot(-lightingMainDirection, end) / endLength;\n    if (near > far)\n    {\n      if (altitudeStart < altitudeEnd)\n      {\n        end = cameraPosition + worldSpaceRay * rayStart;\n        start = cameraPosition + worldSpaceRay * rayEnd;\n        worldSpaceRay *= -1.0;\n        float tmp = altitudeStart;\n        altitudeStart = altitudeEnd;\n        altitudeEnd = tmp;\n      }\n      else if (altitudeStart == altitudeEnd)\n      {\n        altitudeStart += 1.0;\n      }\n    }\n    if (altitudeStart > outerRadius - innerRadius)\n    {\n      scatterDistance = innerRadius - outerRadius;\n    } else\n    {\n      scatterDistance = altitudeEnd - altitudeStart;\n    }\n#endif\n    vec2 opticalStartDepth = exp(scatterDistance * oneOverScaleDepth);\n    float rayLength = rayEnd - rayStart;\n    float sampleLength = rayLength / samples;\n    float scaledLength = sampleLength * shellScale;\n    vec3 sampleRay = worldSpaceRay * sampleLength;\n    vec3 samplePoint = start + sampleRay * 0.5;\n#ifdef HAZE\n    float cameraAngle = dot(-worldSpaceRay, end) / length(end);\n    float scaleCameraAngle = scale(cameraAngle);\n    vec2 cameraOffset = scaleCameraAngle * opticalStartDepth;\n    float scaledValues = scale(lightAngle) + scaleCameraAngle;\n    vec2 scaledValuesDepth = scaledValues * shellDepth;\n#else\n    float cameraAngle = dot(worldSpaceRay, start / length(start));\n    float angleMultiplier = cameraAngle > 0.0 ? cameraAngle : 0.0;\n    float scaleCameraAngle = scale(cameraAngle);\n    vec2 cameraOffset = scaleCameraAngle * opticalStartDepth * shellDepth;\n#endif\n    vec3 frontColor = vec3(0.0);\n    vec3 frontColorBlue = vec3(0.0);\n    vec3 attenuate = vec3(0.0);\n    vec3 attenuateBlue = vec3(0.0);\n    for(int i=0; i<maxSamples; i++) {\n      float height = length(samplePoint);\n      float altitude = abs(height - innerRadius);\n      vec2 depth = exp(-altitude * scaleOverScaleDepth);\n#ifdef HAZE\n      vec2 scatter = depth * scaledValuesDepth - cameraOffset;\n#else\n      float lightAngle = dot(-lightingMainDirection, samplePoint) / height;\n      float cameraAngle = dot(worldSpaceRay, samplePoint) / height;\n      float tmpScaledValues = scale(lightAngle) - scale(cameraAngle);\n      vec2 scatter = cameraOffset + tmpScaledValues * depth * shellDepth;\n#endif\n      attenuate = exp(-scatter.x * invWavelengthScaled);\n      attenuateBlue = exp(-scatter.y * invWavelengthScaled);\n      frontColor += attenuate * depth.x;\n      frontColorBlue += attenuateBlue * depth.y;\n      samplePoint += sampleRay;\n    }\n    float LdotR = clamp(dot(-lightingMainDirection, -worldSpaceRay ),-0.9999999,1.0);\n    float LdotRSq = LdotR * LdotR + 1.0;\n#ifdef HAZE\n    vec3 colorCoefficients = (scaledLength * 0.75 * LdotRSq) * (krESun * invWavelength + kmESun );\n    vec3 color = colorCoefficients * frontColor;\n    vec3 colorBlue = colorCoefficients * frontColorBlue;\n#else\n    vec3 rayleighCoefficients = (scaledLength * 0.75 * LdotRSq * krESun) * invWavelength;\n    float mieCoefficients = scaledLength * kmESun * miePhaseCoefficients * LdotRSq / pow(1.0 + gSq - 2.0 * g * LdotR, 1.5);\n    vec3 color = rayleighCoefficients * frontColor + mieCoefficients * frontColor;\n    vec3 colorBlue = rayleighCoefficients * frontColorBlue + mieCoefficients * frontColorBlue;\n#endif\n    vec3 ldrBlue = expTM(colorBlue, 2.0 * exposure);\n    vec3 ldrRed = expTM(color, exposure);\n    vec3 LDR = mix(ldrBlue, ldrRed, 0.2);\n#ifdef HAZE\n    LDR *= (1.0 - cameraAngle);\n    vec3 hsv = rgb2hsv(LDR);\n    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\n    LDR = hsv2rgb(hsv);\n    vec3 finalColor = LDR;\n#else\n    vec3 ldrReinhard = reinhardTM(color, exposure);\n    LDR += angleMultiplier * ldrReinhard;\n    float side = (rayEnd + rayStart) * 0.5;\n    float atmoHeight = sqrt(cameraHeightSq - side * side);\n    float h2 = clamp(1.0 - ( atmoHeight - lowerAlphaBlendBound ) / ( outerRadius - lowerAlphaBlendBound ), 0.0, 1.0);\n    vec3 finalColor = LDR * h2;\n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y = clamp(hsv.y * 1.5, 0.0, 1.0);\n    finalColor = hsv2rgb(hsv);\n#endif\n#ifndef HAZE\n    float atmosStrength = clamp((length(ldrRed) - 0.05) * 1.05, 0.0, 1.0);\n    gl_FragColor = vec4(finalColor, atmosStrength * clamp(1.0 - ( atmoHeight - innerRadius ) / (outerRadius - innerRadius), 0.0, 1.0));\n    if (surfaceBlend > 0.0) {\n      gl_FragColor = mix(gl_FragColor, surfaceColor, surfaceBlend);\n    }\n#else\n    gl_FragColor = vec4(finalColor, 1.0) * altitudeAlpha;\n#endif\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}","realisticAtmosphere.vert":"#include <util/vsPrecision.glsl>\nuniform vec2 halfSizeNearPlane;\nuniform vec3 cameraUp;\nuniform vec3 cameraRight;\nuniform vec3 cameraDir;\nuniform vec2 cameraCenterOffset;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec3 worldRay;\nvarying vec2 vtc;\n#ifdef HAZE\nvarying vec3 eyeDir;\n#endif\nvoid main(void) {\n  vec3 v3Pos = position;\n  vtc = uv0;\n  vec2 rayvtc = uv0 - cameraCenterOffset;\n#ifdef HAZE\n  eyeDir = vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);\n#else\n  vec3 eyeDir = vec3((2.0 * halfSizeNearPlane * rayvtc) - halfSizeNearPlane, -1.0);\n#endif\n  worldRay = eyeDir.z * cameraDir + eyeDir.y * cameraUp + eyeDir.x * cameraRight;\n  gl_Position = vec4(v3Pos, 1.0);\n}","simpleAtmosphere.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvarying float falloff;\n#ifndef PANORAMIC\nuniform float altitudeFade;\nvarying float innerFactor;\n#endif\nvoid main() {\n  vec4 texColor = texture2D(tex, vtc);\n#ifdef PANORAMIC\n  gl_FragColor = texColor * falloff;\n#else\n  vec4 atmosphereColor = texColor * falloff;\n  vec4 innerColor = vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n  gl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n#endif\n}","simpleAtmosphere.vert":"#include <util/vsPrecision.glsl>\n#include <util/transform.glsl>\nuniform mat4 proj;\nuniform mat4 view;\n#ifndef PANORAMIC\nconst float TWICEPI = 2.0*3.14159265;\nconst float ATMOSPHERE_RIM_SEGMENTS = 128.0;\nuniform vec3 silCircleCenter;\nuniform vec3 silCircleV1;\nuniform vec3 silCircleV2;\nuniform vec2 texV;\nuniform float innerScale;\nvarying float innerFactor;\n#endif\nuniform vec3 lightingMainDirection;\nattribute vec3 position;\nvarying vec2 vtc;\nvarying float falloff;\nvoid main(void) {\n  vec3 lightDirection = -lightingMainDirection;\n#ifdef PANORAMIC\n  vec3 pos = position;\n  float ndotl = lightDirection.z;\n  vtc = vec2(0.0, position.z+0.05);\n#else\n  innerFactor = clamp(-position.z, 0.0, 1.0);\n  float scale = position.y * (1.0 + innerFactor * innerScale);\n  float phi = position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n  vec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n  float ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightDirection);\n  vtc.x = position.x / ATMOSPHERE_RIM_SEGMENTS;\n  vtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;\n#endif\n  falloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  gl_Position = transformPosition(proj, view, pos);\n  gl_Position.z = gl_Position.w;\n}","simpleAtmosphereFade.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","simpleAtmosphereFade.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nuniform vec3 lightingMainDirection;\nuniform vec3 cameraPosition;\nuniform float undergroundFadeAlpha;\nvarying vec4 color;\nvoid main(void) {\n  float ndotl = dot(normalize(cameraPosition), -lightingMainDirection);\n  float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n  color = vec4(vec3(lighting), undergroundFadeAlpha);\n  gl_Position = vec4(position.xy, 1.0, 1.0);\n}","stars.frag":"#include <util/fsPrecision.glsl>\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main() {\n  float cap = 0.7;\n  float scale = 1.0/cap;\n  float helper = clamp(length(abs(gl_PointCoord-vec2(0.5))),0.0,cap);\n  float alpha = clamp((cap-helper)*scale,0.0,1.0);\n  float intensity = alpha*alpha*alpha;\n  if (vsize < 3.0)\n    intensity *= 0.5;\n  gl_FragColor = vec4(1.0,1.0,1.0,intensity);\n  gl_FragColor.xyz *= vcolor.xyz;\n}","stars.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform vec4 viewport;\nuniform float pixelRatio;\nattribute vec3 position;\nattribute vec4 color;\nattribute float size;\nvarying vec4 vcolor;\nvarying float vsize;\nvoid main(void) {\n  vec4 posProj = proj * view * model*vec4(position*1.0e25,1.0);\n  gl_Position = alignToPixelCenter(posProj, viewport.zw);\n  gl_Position.z = gl_Position.w;\n  vcolor = color / 1.2;\n  vsize = size * 5.0 * pixelRatio;\n  gl_PointSize = vsize;\n}"},materials:{hud:{"colorPass.frag":"#include <materials/hud/hudHeader.glsl>\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n}","highlightPass.frag":"#include <materials/hud/hudHeader.glsl>\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\nvoid main() {\n#include <materials/hud/hudMain.glsl>\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\n  if (voccluded == 1.0) {\n    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n  } else {\n    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n  }\n#else\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#endif\n}","hud.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/visualVariables.glsl>\n#include <util/slice.glsl>\nuniform vec2 screenOffset;\nuniform vec2 anchorPos;\nuniform vec2 textureCoordinateScaleFactor;\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspective;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif\nattribute vec2 uv0;\nattribute vec4 color;\nattribute vec2 size;\nattribute vec4 auxpos2;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 posProj = projectPositionHUD(projectAux);\n  if (rejectBySlice(projectAux.posModel)) {\n    gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    return;\n  }\n  vec2 inputSize;\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n  vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n#else\n  inputSize = size;\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n#ifdef VV_SIZE\n  inputSize *= vvGetScale(auxpos2).xx;\n#endif\n  vec2 combinedSize = inputSize * pixelRatio;\n  vec4 quadOffset = vec4(0.0);\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\n  bool visible = testVisibilityHUD(posProj);\n#endif\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvoccluded = visible ? 0.0 : 1.0;\n#endif\n#ifdef OCCL_TEST\n  if (visible) {\n#endif\n    vec2 uv01 = floor(uv0);\n    vec2 uv = uv0 - uv01;\n    quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n#ifdef SIGNED_DISTANCE_FIELD\n    posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n    posProj += quadOffset;\n    if (inputSize.x == size.x) {\n      posProj = alignToPixelOrigin(posProj, viewport.zw);\n    }\n#endif\n    gl_Position = posProj;\n    vtc = uv * textureCoordinateScaleFactor;\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(uv01, 1.5 / combinedSize);\n#endif\n    vsize = inputSize;\n#ifdef OCCL_TEST\n  } else {\n    vtc = vec2(.0);\n#ifdef DEBUG_DRAW_BORDER\n    debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);\n#endif\n  }\n#endif\n  gl_Position = posProj;\n#ifdef VV_COLOR\n  vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors);\n#else\n  vcolor = color / 255.0;\n#endif\n}","hudHeader.glsl":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#include <util/color.glsl>\nuniform sampler2D tex;\nuniform vec4 overrideColor;\nuniform vec4 outlineColor;\nuniform float outlineSize;\nvarying vec4 vcolor;\nvarying vec2 vtc;\nvarying vec2 vsize;\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\nvarying float voccluded;\n#endif\n#ifdef DEBUG_DRAW_BORDER\nvarying vec4 debugBorderCoords;\n#endif","hudMain.glsl":"#ifdef SIGNED_DISTANCE_FIELD\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 fillPixelColor = overrideColor * vcolor;\n  const float txSize = 128.0;\n  const float texelSize = 1.0 / txSize;\n  vec2 scaleFactor = (vsize - txSize) * texelSize;\n  vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n  float d = rgba2float(texture2D(tex, samplePos)) - 0.5;\n  float dist = d * vsize.x;\n  fillPixelColor.a *= clamp(0.5 - dist, 0.0, 1.0);\n  if (outlineSize > 0.25) {\n    vec4 outlinePixelColor = outlineColor;\n    float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n    outlinePixelColor.a *= clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n    float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n      vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n    gl_FragColor = vec4(compositeColor, compositeAlpha);\n  }\n  else {\n    gl_FragColor = premultiplyAlpha(fillPixelColor);\n  }\n#else\n  gl_FragColor = texture2D(tex, vtc, -0.5) * premultiplyAlpha(overrideColor * vcolor);\n#endif\n#ifdef DEBUG_DRAW_BORDER\n   float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));\n   gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);\n#endif\n  if (gl_FragColor.a < 0.1) {\n    discard;\n  }","occlusionTest.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}","occlusionTest.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nvoid main(void) {\n  vec4 posProjCenter;\n  if (dot(position, position) > 0.0) {\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n    posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n  }\n  else {\n    posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n  }\n  gl_Position = posProjCenter;\n  gl_PointSize = 1.0;\n}"},lineCallout:{"lineCallout.frag":"#include <util/fsPrecision.glsl>\nuniform vec4 color;\nuniform vec4 borderColor;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main() {\n  vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n  float borderAlpha = color.a * borderColor.a * coverage.y;\n  float colorAlpha = color.a * coverage.x;\n  float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n#ifdef DEPTH_HUD\n  if (finalAlpha < 0.01) {\n    discard;\n  }\n#else\n  vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n  gl_FragColor = vec4(finalRgb, finalAlpha);\n#endif\n}","lineCallout.vert":"#include <util/vsPrecision.glsl>\n#include <util/alignPixel.glsl>\n#include <util/hud.glsl>\n#include <util/slice.glsl>\nattribute vec2 uv0;\nuniform float lineSize;\nuniform vec2 pixelToNDC;\nuniform float borderSize;\nuniform vec2 screenOffset;\nvarying vec4 coverageSampling;\nvarying vec2 lineSizes;\nvoid main(void) {\n  ProjectHUDAux projectAux;\n  vec4 endPoint = projectPositionHUD(projectAux);\n  vec3 vpos = projectAux.posModel;\n  if (rejectBySlice(vpos)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#ifdef OCCL_TEST\n  if (!testVisibilityHUD(endPoint)) {\n    gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n    return;\n  }\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n  vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n#else\n  vec2 screenOffsetScaled = screenOffset;\n#endif\n  vec3 posView = (view * (model * vec4(position, 1.0))).xyz;\n  applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\n  vec4 startPoint = proj * vec4(posView, 1.0);\n  vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n  startPoint.xy += screenOffsetNorm * startPoint.w;\n  endPoint.xy += screenOffsetNorm * endPoint.w;\n  vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n  vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n#ifdef DEPTH_HUD\n#ifdef DEPTH_HUD_ALIGN_START\n  endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\n#else\n  startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\n#endif\n#endif\n  vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n  vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n  vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n  float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n#else\n  float lineSizeScaled = lineSize;\n  float borderSizeScaled = borderSize;\n#endif\n  float halfPixelSize = lineSizeScaled * 0.5;\n  float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n  float halfPixelSizeInt = floor(halfWholePixelSize);\n  float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n  float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n  float padding = 1.0 + borderSizeScaled;\n  vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n  projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n  float edgeDirection = (uv0.x * 2.0 - 1.0);\n  float halfBorderSize = 0.5 * borderSizeScaled;\n  float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n  float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n  float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n  coverageSampling = vec4(\n    outerEdgeCoverageSampler,\n    outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n    halfPixelSize - 0.5,\n    halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n  );\n  lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n  gl_Position = projectedPosition;\n}"},measurementArrow:{"measurementArrow.frag":"#include <util/fsPrecision.glsl>\nuniform float outlineSize;\nuniform vec4 outlineColor;\nuniform float stripeLength;\nuniform vec4 stripeEvenColor;\nuniform vec4 stripeOddColor;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\n#define INV_SQRT2 (1.0 / sqrt(2.0))\nvec4 arrowColor(vec2 tc, float len) {\n  float d = INV_SQRT2 * (tc.x - abs(tc.y));\n  d = min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\n  d = min(d, 1.0 - abs(tc.y));\n  if (d < 0.0) {\n    return vec4(0.0);\n  } else if (d < outlineSize) {\n    return outlineColor;\n  } else {\n    return fract(0.5 / stripeLength * tc.x * vradius) >= 0.5 ? stripeOddColor : stripeEvenColor;\n  }\n}\nvoid main(void) {\n  vec2 ntc = vec2(vtc.x / vradius, vtc.y);\n  vec4 color = arrowColor(ntc, vlength / vradius);\n  if (color.a == 0.0) {\n    discard;\n  }\n  gl_FragColor = color;\n}","measurementArrow.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nuniform float width;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv0;\nattribute float auxpos1;\nvarying vec2 vtc;\nvarying float vlength;\nvarying float vradius;\nvoid main(void) {\n  vec3 bitangent = normal;\n  vtc = uv0;\n  vlength = auxpos1;\n  vradius = 0.5 * width;\n  vec4 pos = view * vec4((model * vec4(position + vradius * bitangent * uv0.y, 1.0)).xyz, 1.0);\n  gl_Position = proj * pos;\n}"},slicePlane:{"slicePlane.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\nuniform vec4 backgroundColor;\nuniform vec4 gridColor;\nuniform float ratio;\nuniform float gridWidth;\nvarying vec2 vUV;\nvoid main() {\n  const float LINE_WIDTH = 1.0;\n  vec2 uvScaled = vUV * gridWidth;\n  vec2 gridUV = (fract(uvScaled + 0.5) - 0.5) / (LINE_WIDTH * fwidth(uvScaled));\n  vec2 grid = (1.0 - step(0.5, gridUV)) * step(-0.5, gridUV);\n  grid.x *= step(0.5, uvScaled.x) * step(uvScaled.x, gridWidth - 0.5);\n  grid.y *= step(0.5, uvScaled.y) * step(uvScaled.y, gridWidth - 0.5);\n  float gridFade = max(grid.x, grid.y);\n  float gridAlpha = gridColor.a * gridFade;\n  gl_FragColor =\n    vec4(backgroundColor.rgb * backgroundColor.a, backgroundColor.a) * (1.0 - gridAlpha) +\n    vec4(gridColor.rgb, 1.0) * gridAlpha;\n}","slicePlane.vert":"#include <util/vsPrecision.glsl>\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 model;\nattribute vec3 position;\nattribute vec2 uv0;\nvarying vec2 vUV;\nvoid main(void) {\n  vUV = uv0;\n  gl_Position = proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\n}"}},pointRenderer:{"pointRenderer.frag":"#include <util/fsPrecision.glsl>\n#include <util/encoding.glsl>\n#ifdef HIGHLIGHT_PASS\n#include <util/highlight.glsl>\nuniform sampler2D depthTex;\nuniform vec4 highlightViewportPixelSz;\n#endif\n#ifdef DEPTH_PASS\nvarying float depth;\n#elif defined(HIGHLIGHT_PASS)\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);\n  float r2 = dot(vOffset, vOffset);\n  if (r2 > 0.25) {\n    discard;\n  }\n#ifdef DEPTH_PASS\n  gl_FragColor = float2rgba(depth);\n#elif defined(HIGHLIGHT_PASS)\n  gl_FragColor = highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n#else\n  gl_FragColor = vec4(vColor, 1.0);\n#endif\n}","pointRenderer.vert":"#include <util/slice.glsl>\n#include <util/vsPrecision.glsl>\nattribute vec3 aPosition;\nattribute vec3 aColor;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec2 uScreenMinMaxSize;\nuniform vec2 uPointScale;\nuniform vec3 uClipMin;\nuniform vec3 uClipMax;\n#ifdef DEPTH_PASS\nuniform vec2 nearFar;\nvarying float depth;\n#else\nvarying vec3 vColor;\n#endif\nvoid main(void) {\n  if (aPosition.x < uClipMin.x || aPosition.y < uClipMin.y || aPosition.z < uClipMin.z ||\n      aPosition.x > uClipMax.x || aPosition.y > uClipMax.y || aPosition.z > uClipMax.z) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  if (rejectBySlice(aPosition)) {\n    gl_Position = vec4(0.0,0.0,0.0,2.0);\n    gl_PointSize = 0.0;\n    return;\n  }\n  vec4 camera = uModelViewMatrix * vec4(aPosition, 1.0);\n  float pointSize = uPointScale.x;\n  vec4 position = uProjectionMatrix * camera;\n#ifdef DRAW_SCREEN_SIZE\n    float clampedScreenSize = pointSize;\n#else\n    float pointRadius = 0.5 * pointSize;\n    vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);\n    vec4 positionOffset = uProjectionMatrix * cameraOffset;\n    float radius = abs(positionOffset.y - position.y);\n    float viewHeight = uPointScale.y;\n    float screenPointSize = (radius / position.w) * viewHeight;\n    float clampedScreenSize = clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);\n    camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\n    position = uProjectionMatrix * camera;\n#endif\n  gl_PointSize = clampedScreenSize;\n  gl_Position = position;\n#ifdef DEPTH_PASS\n  depth = (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\n#else\n  vColor = aColor;\n#endif\n}"},renderer:{highlight:{"apply.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform sampler2D origin;\nuniform vec4 color;\nuniform vec4 haloColor;\nuniform float outlineSize;\nuniform float blurSize;\nuniform vec4 opacities;\nvarying vec2 uv;\nvoid main() {\n  #if defined(GRID_OPTIMIZATION) && defined(GRID_DEBUG)\n    gl_FragColor = vec4(uv, 0.0, 1.0);\n  #else\n    vec4 blurredHighlightValue = texture2D(tex, uv);\n    float highlightIntensity = blurredHighlightValue.a;\n    if (highlightIntensity == 0.0) {\n      discard;\n    }\n    vec4 origin_color = texture2D(origin, uv);\n    float outlineIntensity;\n    float fillIntensity;\n    if (blurredHighlightValue.g > blurredHighlightValue.b) {\n      outlineIntensity = haloColor.w * opacities[1];\n      fillIntensity = color.w * opacities[3];\n    }\n    else {\n      outlineIntensity = haloColor.w * opacities[0];\n      fillIntensity = color.w * opacities[2];\n    }\n    float inner = 1.0 - outlineSize / 9.0;\n    float outer = 1.0 - (outlineSize + blurSize) / 9.0;\n    float outlineFactor = smoothstep(outer, inner, highlightIntensity);\n    float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\n    float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\n    gl_FragColor = vec4(mix(haloColor.rgb, color.rgb, fillFactor), intensity);\n  #endif\n}","apply.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\n#ifdef GRID_OPTIMIZATION\n  attribute vec2 uv0;\n  uniform sampler2D coverageTex;\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    #ifdef GRID_DEBUG\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0 || cov.g == 1.0 || cov.b == 1.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n      gl_Position = vec4(position, .0, 1.0);\n      uv = uv0;\n      return;\n    #else\n      vec4 cov = texture2D(coverageTex, uv0);\n      if (cov.r == 0.0) {\n        gl_Position = vec4(0.0);\n        return;\n      }\n    #endif\n  #endif\n  gl_Position = vec4(position, .0, 1.0);\n  uv = position.xy * .5 + vec2(.5);\n}",
"blur.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\n#ifdef GRID_OPTIMIZATION\n  uniform vec2 blurSize;\n  varying vec3 blurCoordinate;\n#else\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  #ifdef GRID_OPTIMIZATION\n    vec2 uv = blurCoordinate.xy;\n    vec4 center = texture2D(tex, uv);\n    if (blurCoordinate.z == 1.0) {\n      gl_FragColor = center;\n    }\n    else {\n      vec4 sum = vec4(0.0);\n      #if GAUSSIAN_SAMPLES == 3\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n      #elif GAUSSIAN_SAMPLES == 5\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n      #elif GAUSSIAN_SAMPLES == 7\n        sum += center * 0.204164;\n        sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n        sum += texture2D(tex, uv + blurSize * 5.1) * 0.03;\n        sum += texture2D(tex, uv - blurSize * 5.1) * 0.03;\n      #elif GAUSSIAN_SAMPLES == 9\n        sum += center * 0.154164;\n        sum += texture2D(tex, uv + blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv - blurSize * 1.5) * 0.204005;\n        sum += texture2D(tex, uv + blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 3.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv - blurSize * 5.5) * 0.123913;\n        sum += texture2D(tex, uv + blurSize * 7.5) * 0.05;\n        sum += texture2D(tex, uv - blurSize * 7.5) * 0.05;\n      #endif\n      gl_FragColor = sum;\n    }\n  #else\n    vec4 sum = vec4(0.0);\n    #if GAUSSIAN_SAMPLES == 3\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n    #elif GAUSSIAN_SAMPLES == 5\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n    #elif GAUSSIAN_SAMPLES == 7\n      sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.03;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.03;\n    #elif GAUSSIAN_SAMPLES == 9\n      sum += texture2D(tex, blurCoordinates[0]) * 0.154164;\n      sum += texture2D(tex, blurCoordinates[1]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[2]) * 0.204005;\n      sum += texture2D(tex, blurCoordinates[3]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[4]) * 0.123913;\n      sum += texture2D(tex, blurCoordinates[5]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[6]) * 0.09;\n      sum += texture2D(tex, blurCoordinates[7]) * 0.05;\n      sum += texture2D(tex, blurCoordinates[8]) * 0.05;\n    #endif\n    gl_FragColor = sum;\n  #endif\n}","blur.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nattribute vec2 uv0;\n#ifdef GRID_OPTIMIZATION\n  uniform sampler2D coverageTex;\n  varying vec3 blurCoordinate;\n#else\n  uniform vec2 blurSize;\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n#endif\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n  #ifdef GRID_OPTIMIZATION\n    vec4 cov = texture2D(coverageTex, uv0);\n    if (cov.r == 0.0) {\n      gl_Position = vec4(0.0);\n    }\n    blurCoordinate = vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\n  #else\n    vec2 uv = position.xy * .5 + vec2(.5);\n    #if GAUSSIAN_SAMPLES == 3\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n    #elif GAUSSIAN_SAMPLES == 5\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n    #elif GAUSSIAN_SAMPLES == 7\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n    #elif GAUSSIAN_SAMPLES == 9\n      blurCoordinates[0] = uv;\n      blurCoordinates[1] = uv + blurSize * 1.407333;\n      blurCoordinates[2] = uv - blurSize * 1.407333;\n      blurCoordinates[3] = uv + blurSize * 3.294215;\n      blurCoordinates[4] = uv - blurSize * 3.294215;\n      blurCoordinates[5] = uv + blurSize * 5.1;\n      blurCoordinates[6] = uv - blurSize * 5.1;\n      blurCoordinates[7] = uv + blurSize * 7.1;\n      blurCoordinates[8] = uv - blurSize * 7.1;\n    #endif\n  #endif\n}","downsample.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nuniform vec2 invFramebufferDim;\nvoid main() {\n  vec2 coord = gl_FragCoord.xy * invFramebufferDim;\n  vec4 value = texture2D(tex, coord);\n  float mx = floor(max(value.g, value.b));\n  gl_FragColor = vec4(ceil(value.r), mx, mx, 1.0);\n}","downsample.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(vec2(1.0) - position * 2.0, .0, 1.0);\n}"},laserLine:{"laserLine.frag":"#include <util/enableExtensions.glsl>\n#include <util/fsPrecision.glsl>\n#include <util/depth.glsl>\nuniform sampler2D depthMap;\nuniform vec2 nearFar;\nuniform vec4 projInfo;\nuniform vec2 zScale;\nuniform float maxPixelDistance;\nuniform vec4 focusPlane;\nuniform vec4 focusSphere;\nuniform vec4 segmentPlane;\nuniform vec3 segmentStart;\nuniform vec3 segmentEnd;\nuniform vec3 glowColor;\nuniform float glowWidth;\nuniform vec3 innerColor;\nuniform float innerWidth;\nuniform float globalAlpha;\nvarying vec2 uv;\n#define INFINITY 100000.0\nvec3 reconstructPosition(vec2 fragCoord, float depth) {\n  return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\n}\nfloat planeDistancePixels(vec4 plane, vec3 pos) {\n  float dist = dot(plane.xyz, pos) + plane.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nfloat sphereDistancePixels(vec4 sphere, vec3 pos) {\n  float dist = distance(sphere.xyz, pos) - sphere.w;\n  float width = fwidth(dist);\n  dist /= min(width, maxPixelDistance);\n  return abs(dist);\n}\nvec4 blendPremultiplied(vec4 source, vec4 dest) {\n  float oneMinusSourceAlpha = 1.0 - source.a;\n  return vec4(\n    source.rgb + dest.rgb * oneMinusSourceAlpha,\n    source.a + dest.a * oneMinusSourceAlpha\n  );\n}\nvec4 premultipliedColor(vec3 rgb, float alpha) {\n  return vec4(rgb * alpha, alpha);\n}\nvec4 laserLineProfile(float dist) {\n  if (dist > glowWidth) {\n    return vec4(0.0);\n  }\n  float innerAlpha = (1.0 - smoothstep(0.0, innerWidth, dist));\n  float glowAlpha = pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\n  return blendPremultiplied(\n    premultipliedColor(innerColor, innerAlpha),\n    premultipliedColor(glowColor, glowAlpha)\n  );\n}\nvoid main() {\n  float depth = linearDepth(depthMap, uv, nearFar);\n  if (-depth == nearFar[0]) {\n    discard;\n  }\n  vec3 pos = reconstructPosition(gl_FragCoord.xy, depth);\n  float ddepth = fwidth(depth);\n  float depthDiscontinuityAlpha = 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\n  vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));\n  float focusPlaneDistance = planeDistancePixels(focusPlane, pos);\n  float focusSphereDistance = sphereDistancePixels(focusSphere, pos);\n  float segmentDistance = INFINITY;\n  float segmentLength = length(segmentEnd - segmentStart);\n  vec3 segmentDir = (segmentEnd - segmentStart) / segmentLength;\n  float t = dot(segmentDir, pos - segmentStart);\n  if (segmentLength > 0.0 && t >= 0.0 && t <= segmentLength) {\n    segmentDistance = planeDistancePixels(segmentPlane, pos);\n  }\n  vec4 focusPlaneColor = laserLineProfile(focusPlaneDistance);\n  vec4 focusSphereColor = laserLineProfile(focusSphereDistance);\n  vec4 segmentColor = laserLineProfile(segmentDistance);\n  float focusPlaneAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\n  float focusSphereAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\n  float segmentAlpha = 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\n  vec4 color = max(\n    focusPlaneColor * focusPlaneAlpha,\n    max(\n      focusSphereColor * focusSphereAlpha,\n      segmentColor * segmentAlpha\n    )\n  );\n  gl_FragColor = color * globalAlpha * depthDiscontinuityAlpha;\n}"},offscreen:{"composite.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = texture2D(tex, vtc);\n}","compositeOccluded.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D occludedColorMap;\nuniform float opacity;\nvarying vec2 vtc;\nvoid main() {\n  vec4 occludedColor = texture2D(occludedColorMap, vtc);\n  gl_FragColor = occludedColor * opacity;\n}","compositeTransparentToHUDVisibility.frag":"#include <util/fsPrecision.glsl>\nuniform sampler2D tex;\nvarying vec2 vtc;\nvoid main() {\n  gl_FragColor = vec4(1.0 - texture2D(tex, vtc).a);\n}","offscreen.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 vtc;\nvoid main(void) {\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n  vtc = position.xy * 0.5 + 0.5;\n}"}},util:{"alignPixel.glsl":"vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}\nvec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\n  vec2 xy = vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\n  vec2 pixelSz = vec2(1.0) / widthHeight;\n  vec2 ij = floor((xy + .5 * pixelSz) * widthHeight) * pixelSz;\n  vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\n  return vec4(result, clipCoord.zw);\n}","color.glsl":"vec4 premultiplyAlpha(vec4 v) {\n  return vec4(v.rgb * v.a, v.a);\n}\nvec3 rgb2hsv(vec3 c) {\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat rgb2v(vec3 c) {\n  return max(c.x, max(c.y, c.z));\n}","depth.glsl":"#include <util/encoding.glsl>\nfloat linearDepth(sampler2D depthTex, vec2 uv, vec2 nearFar) {\n  return -(rgba2float(texture2D(depthTex, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\n}\nfloat calcFragDepth(const in float depth) {\n  const float SLOPE_SCALE = 2.0;\n  const float BIAS = 2.0 * .000015259;\n  float m = max(abs(dFdx(depth)), abs(dFdy(depth)));\n  float result = depth + SLOPE_SCALE * m + BIAS;\n  return clamp(result, .0, .999999);\n}","doublePrecision.glsl":"#ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION\nvec3 dpPlusFrc(vec3 a, vec3 b) {\n  return mix(a, a + b, vec3(notEqual(b, vec3(0))));\n}\nvec3 dpMinusFrc(vec3 a, vec3 b) {\n  return mix(vec3(0), a - b, vec3(notEqual(a, b)));\n}\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = dpPlusFrc(hiA, hiB);\n  vec3 e = dpMinusFrc(t1, hiA);\n  vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;\n  return t1 + t2;\n}\n#else\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\n  vec3 t1 = hiA + hiB;\n  vec3 e = t1 - hiA;\n  vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\n  return t1 + t2;\n}\n#endif","enableExtensions.glsl":"#define EXTENSIONS_ENABLED\n#extension GL_OES_standard_derivatives : enable\n#extension GL_EXT_shader_texture_lod : enable","encoding.glsl":"const float MAX_RGBA_FLOAT =\n  255.0 / 256.0 +\n  255.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 +\n  255.0 / 256.0 / 256.0 / 256.0 / 256.0;\nconst vec4 fixedPointFactors = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\nvec4 float2rgba(const float value) {\n  float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);\n  vec4 fixedPointU8 = floor(fract(valueInValidDomain * fixedPointFactors) * 256.0);\n  const float toU8AsFloat = 1.0 / 255.0;\n  return fixedPointU8 * toU8AsFloat;\n}\nconst vec4 rgba2float_factors = vec4(\n  255.0 / (256.0),\n  255.0 / (256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0),\n  255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\n  return dot(rgba, rgba2float_factors);\n}","fsPrecision.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp sampler2D;\n#else\nprecision mediump float;\nprecision mediump sampler2D;\n#endif","highlight.glsl":"vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\n  float sceneDepth = texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\n  if (fragCoord.z > sceneDepth + 5e-7) {\n    return vec4(1.0, 1.0, 0.0, 1.0);\n  }\n  else {\n    return vec4(1.0, 0.0, 1.0, 1.0);\n  }\n}","hud.glsl":"#include <util/screenSizePerspective.glsl>\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec4 auxpos1;\nuniform mat4 proj;\nuniform mat4 view;\nuniform mat4 viewNormal;\nuniform mat4 model;\nuniform mat4 modelNormal;\nuniform vec4 viewport;\nuniform vec3 camPos;\nuniform float polygonOffset;\nuniform float cameraGroundRelative;\nuniform float pixelRatio;\nuniform float perDistancePixelRatio;\n#ifdef VERTICAL_OFFSET\nuniform vec4 verticalOffset;\n#endif\n#ifdef SCREEN_SIZE_PERSPECTIVE\nuniform vec4 screenSizePerspectiveAlignment;\n#endif\nuniform sampler2D hudVisibilityTexture;\nconst float SMALL_OFFSET_ANGLE = 0.984807753012208;\nstruct ProjectHUDAux {\n  vec3 posModel;\n  vec3 posView;\n  vec3 vnormal;\n  float distanceToCamera;\n  float absCosAngle;\n};\nfloat applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n  float pointGroundSign = sign(pointGroundDistance);\n  if (pointGroundSign == 0.0) {\n    pointGroundSign = cameraGroundRelative;\n  }\n  float groundRelative = cameraGroundRelative * pointGroundSign;\n  if (polygonOffset > .0) {\n    float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n    float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n    float factor = (1.0 - tanAlpha / viewport[2]);\n    if (groundRelative > 0.0) {\n      posView *= factor;\n    }\n    else {\n      posView /= factor;\n    }\n  }\n  return groundRelative;\n}\nvoid applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n  float distanceToCamera = length(posView);\n  float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;\n  vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  posModel += modelOffset;\n  posView += viewOffset;\n}\nvec4 projectPositionHUD(out ProjectHUDAux aux) {\n  vec3 centerOffset = auxpos1.xyz;\n  float pointGroundDistance = auxpos1.w;\n  aux.posModel = (model * vec4(position, 1.0)).xyz;\n  aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n  aux.vnormal = (modelNormal * vec4(normal, 1.0)).xyz;\n  applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\n  aux.distanceToCamera = length(aux.posView);\n  vec3 viewDirObjSpace = normalize(camPos - aux.posModel);\n  float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n  aux.absCosAngle = abs(cosAngle);\n#ifdef SCREEN_SIZE_PERSPECTIVE\n#if defined(VERTICAL_OFFSET) || defined(CENTER_OFFSET_UNITS_SCREEN)\n  vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\n#endif\n#endif\n#ifdef VERTICAL_OFFSET\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\n#else\n  float verticalOffsetScreenHeight = verticalOffset.x;\n#endif\n  float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n  vec3 modelOffset = aux.vnormal * worldOffset;\n  aux.posModel += modelOffset;\n  vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n  aux.posView += viewOffset;\n  pointGroundDistance += worldOffset;\n#endif\n  float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n#ifndef CENTER_OFFSET_UNITS_SCREEN\n  aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n  if (centerOffset.z != 0.0) {\n    aux.posView -= normalize(aux.posView) * centerOffset.z;\n  }\n#endif\n  vec4 posProj = proj * vec4(aux.posView, 1.0);\n#ifdef CENTER_OFFSET_UNITS_SCREEN\n#ifdef SCREEN_SIZE_PERSPECTIVE\n  float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\n#else\n  float centerOffsetY = centerOffset.y;\n#endif\n  posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\n#endif\n  posProj.z -= groundRelative * polygonOffset * posProj.w;\n  return posProj;\n}\nuniform float uRenderTransparentlyOccludedHUD;\nbool testVisibilityHUD(vec4 posProj) {\n  vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n  vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\n  if (uRenderTransparentlyOccludedHUD > 0.5) {\n    return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;\n  }\n  return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}","quad.vert":"#include <util/vsPrecision.glsl>\nattribute vec2 position;\nvarying vec2 uv;\nvoid main(void) {\n  gl_Position = vec4(position.x, position.y, .0, 1.0);\n  uv = position * .5 + vec2(.5);\n}","screenSizePerspective.glsl":"float screenSizePerspectiveMinSize(float size, vec4 factor) {\n  float nonZeroSize = 1.0 - step(size, 0.0);\n  return (\n    factor.z * (\n      1.0 +\n      nonZeroSize *\n      2.0 * factor.w / (\n        size + (1.0 - nonZeroSize)\n      )\n    )\n  );\n}\nfloat screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\n  return absCosAngle * absCosAngle * absCosAngle;\n}\nvec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\n  return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\n}\nfloat applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\n  return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\n}\nfloat screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}\nvec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\n  return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\n}\nvec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\n  return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\n}","slice.glsl":"#ifdef SLICE\nuniform vec3 slicePlaneOrigin;\nuniform vec3 slicePlaneBasis1;\nuniform vec3 slicePlaneBasis2;\nstruct SliceFactors {\n  float front;\n  float side0;\n  float side1;\n  float side2;\n  float side3;\n};\nSliceFactors calculateSliceFactors(vec3 pos) {\n  vec3 rel = pos - slicePlaneOrigin;\n  vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);\n  float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);\n  float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);\n  float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);\n  float basis1Dot = dot(slicePlaneBasis1, rel);\n  float basis2Dot = dot(slicePlaneBasis2, rel);\n  return SliceFactors(\n    dot(slicePlaneNormal, pos) + slicePlaneW,\n    -basis1Dot - basis1Len2,\n    basis1Dot - basis1Len2,\n    -basis2Dot - basis2Len2,\n    basis2Dot - basis2Len2\n  );\n}\nbool sliceByFactors(SliceFactors factors) {\n  return factors.front < 0.0\n    && factors.side0 < 0.0\n    && factors.side1 < 0.0\n    && factors.side2 < 0.0\n    && factors.side3 < 0.0;\n}\nbool sliceByPlane(vec3 pos) {\n  return sliceByFactors(calculateSliceFactors(pos));\n}\n#ifdef EXTENSIONS_ENABLED\nvec4 applySliceHighlight(vec4 color, vec3 pos) {\n  SliceFactors factors = calculateSliceFactors(pos);\n  if (sliceByFactors(factors)) {\n    return color;\n  }\n  const float HIGHLIGHT_WIDTH = 1.0;\n  const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);\n  factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\n  factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\n  factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\n  factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\n  factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\n  float highlightFactor = (1.0 - step(0.5, factors.front))\n    * (1.0 - step(0.5, factors.side0))\n    * (1.0 - step(0.5, factors.side1))\n    * (1.0 - step(0.5, factors.side2))\n    * (1.0 - step(0.5, factors.side3));\n  return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\n}\n#else\n#endif\n#define rejectBySlice(_pos_) sliceByPlane(_pos_)\n#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\n#ifdef SLICE_HIGHLIGHT_DISABLED\n#define highlightSlice(_color_, _pos_) (_color_)\n#else\n#define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\n#endif\n#else\n#define rejectBySlice(_pos_) false\n#define discardBySlice(_pos_) {}\n#define highlightSlice(_color_, _pos_) (_color_)\n#endif","transform.glsl":"vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {\n  return proj * (view * vec4(pos, 1.0));\n}\nvec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {\n  vec4 eye = view * vec4(pos, 1.0);\n  depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\n  return proj * eye;\n}","visualVariables.glsl":"#ifdef VV_COLOR\n  #define VV_COLOR_N 8\n  uniform float vvColorValues[VV_COLOR_N];\n  uniform vec4 vvColorColors[VV_COLOR_N];\n#endif\n#ifdef VV_SIZE\n  uniform vec3 vvSizeMinSize;\n  uniform vec3 vvSizeMaxSize;\n  uniform vec3 vvSizeOffset;\n  uniform vec3 vvSizeFactor;\n  uniform mat3 vvSymbolRotationMatrix;\n  uniform vec3 vvSymbolAnchor;\n  vec3 vvGetScale(vec4 featureAttribute) {\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\n  }\n  vec4 vvTransformPosition(vec3 position, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * (vvGetScale(featureAttribute) * (position + vvSymbolAnchor)), 1.0);\n  }\n  vec4 vvTransformNormal(vec3 normal, vec4 featureAttribute) {\n    return vec4(vvSymbolRotationMatrix * normal / vvGetScale(featureAttribute), 1.0);\n  }\n#endif\n#ifdef VV_COLOR\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\n    float value = featureAttribute.y;\n    if (value <= values[0]) {\n      return colors[0];\n    }\n    for (int i = 1; i < VV_COLOR_N; ++i) {\n      if (values[i] >= value) {\n        float f = (value - values[i-1]) / (values[i] - values[i-1]);\n        return mix(colors[i-1], colors[i], f);\n      }\n    }\n    return colors[VV_COLOR_N - 1];\n  }\n#endif","vsPrecision.glsl":"precision highp float;\nprecision highp sampler2D;"}}});